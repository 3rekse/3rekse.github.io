import{o as t,c as n,k as s,q as r,s as l,B as i,e}from"./modules/vue-9M24w38T.js";import{I as c}from"./slidev/default-Baua-wYJ.js";import{u as p,f as d}from"./slidev/context-BrpKgFPm.js";import"./index-CErdVrjL.js";import"./modules/shiki-D165QSPi.js";const u=e("p",null,"Quando viene eseguita un’istruzione di trap, come abbiamo discusso prima, essa di solito fa un numero di cose interessanti.",-1),m=e("p",null,"La più importante nel nostro esempio è che trasferisce il controllo (cioè cambia il PC) a un gestore di trap ben definito all’interno del sistema operativo.",-1),_=e("p",null,"Il sistema operativo, quando si avvia per la prima volta, stabilisce l’indirizzo di una tale routine con l’hardware (anche questa è un’operazione privilegiata) e quindi, durante i trap successivi, l’hardware sa dove iniziare a eseguire il codice per gestire il trap.",-1),v=e("p",null,"Allo stesso tempo del trap, l’hardware fa anche un’altra cosa cruciale: cambia la modalità del processore da modalità utente a modalità kernel.",-1),f=e("p",null,"In modalità utente, le operazioni sono limitate e i tentativi di eseguire operazioni privilegiate porteranno a un trap e probabilmente alla terminazione del processo offensivo.",-1),h=e("p",null,"In modalità kernel, invece, è disponibile tutta la potenza della macchina e quindi tutte le operazioni privilegiate possono essere eseguite.",-1),z=e("p",null,"Pertanto, in un contesto tradizionale (ancora, senza virtualizzazione), il flusso di controllo sarebbe come quello che vedi nella Figura B.1.",-1),g={__name:"virtualMachine.md__slidev_623",setup(b){const{$slidev:$,$nav:k,$clicksContext:a,$clicks:q,$page:x,$renderContext:B,$frontmatter:o}=p();return a.setup(),(C,I)=>(t(),n(c,r(l(i(d)(i(o),622))),{default:s(()=>[u,m,_,v,f,h,z]),_:1},16))}},A=g;export{A as default};
