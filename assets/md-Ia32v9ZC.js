import{_ as s}from"./slidev/Link.vue_vue_type_script_setup_true_lang-DaKcUw9x.js";import{b as u,o as m,w as a,g as o,C as t,e as d,v as p,x as g,B as n}from"./modules/vue-BXqLZby3.js";import{I as f}from"./slidev/default-CgjpOQvn.js";import{u as v,f as B}from"./slidev/context-_s_nlYTD.js";import"./index-CKoLJ0an.js";import"./modules/shiki-D1VZkxQz.js";const k={__name:"logic-gates.md__slidev_523",setup(q){const{$clicksContext:i,$frontmatter:r}=v();return i.setup(),(z,e)=>{const l=s;return m(),u(f,p(g(n(B)(n(r),522))),{default:a(()=>[e[5]||(e[5]=o("h2",null,"Combined logic - Part 4",-1)),e[6]||(e[6]=o("p",null,[t("Tuttavia, se prendiamo le altre due condizioni inutilizzate dalla tabella di verità che rendono l’operazione XOR "),o("code",null,"false"),t(", possiamo creare l’equazione negativa per XOR, chiamata NXOR:")],-1)),e[7]||(e[7]=o("p",null,[o("code",null,"~(A ⊕ B)"),t(" = "),o("code",null,"(~A · ~B) + (A · B)")],-1)),o("p",null,[e[1]||(e[1]=t("Per tornare a ")),e[2]||(e[2]=o("code",null,"A ⊕ B",-1)),e[3]||(e[3]=t(" dobbiamo negare questa equazione negativa. Poi, con l’aiuto del ")),d(l,{to:"/logic-lab/expressions#de-morgan-s-thereom"},{default:a(()=>e[0]||(e[0]=[t("Teorema di De Morgan")])),_:1,__:[0]}),e[4]||(e[4]=t(", otteniamo un’equazione diversa per XOR ma è comunque logicamente equivalente a quella originale."))]),e[8]||(e[8]=o("p",null,[o("code",null,"A ⊕ B"),t(" = "),o("code",null,"(A + B) · ~(A · B)")],-1)),e[9]||(e[9]=o("p",null,"Quando questa equazione viene convertita in porte logiche, c’è una porta in meno rispetto al primo diagramma.",-1))]),_:1,__:[5,6,7,8,9]},16)}}};export{k as default};
