import{b as n,o as s,w as o,g as e,v as u,x as d,B as t}from"./modules/vue-BXqLZby3.js";import{I as m}from"./slidev/two-cols-header-PTGXvaFV.js";import{u as p,f as c}from"./slidev/context-Co-6DO2t.js";import"./index-CDGWvc22.js";import"./modules/shiki-D1VZkxQz.js";const g="/logica/3_6.png",b={__name:"sequenziale.md__slidev_545",setup(f){const{$clicksContext:r,$frontmatter:l}=p();return r.setup(),(v,i)=>(s(),n(m,u(d(t(c)(t(l),544))),{right:o(a=>i[0]||(i[0]=[e("p",null,[e("img",{src:g,alt:"dflipflop"})],-1)])),left:o(a=>i[1]||(i[1]=[e("p",null,"Leggi: Per leggere il contenuto del registro numero m, inseriamo m nell’input dell’indirizzo.",-1),e("p",null,"Scrivi: Per scrivere un nuovo valore di dati d nel registro numero m, inseriamo m nel input dell’indirizzo, d nell’input in, e affermiamo il bit di input di load. Questo fa sì che la logica di accesso diretto della RAM selezioni il registro numero m, e il bit di carico lo abiliti. Nel prossimo ciclo di clock, il registro selezionato si impegnerà con il nuovo valore (d), e l’ output della RAM inizierà a emetterlo.",-1)])),default:o(()=>[i[2]||(i[2]=e("h2",null,"Ora tocca a te",-1)),i[3]||(i[3]=e("p",null,"Costruire una gerarchia di tali dispositivi di memoria, tutti larghi 16 bit, ma di dimensioni variabili: unità RAM8, RAM64, RAM512, RAM4K e RAM16K. Tutti questi chip di memoria hanno esattamente la stessa API, e quindi li descriviamo in un unico diagramma parametrico",-1)),i[4]||(i[4]=e("p",null,"La logica di accesso diretto della RAM selezionerà il registro numero m, che poi emetterà il suo valore di output al pin di output della RAM. Questa è un’operazione combinatoria, indipen- dente dal clock.",-1))]),_:1,__:[2,3,4]},16))}};export{b as default};
