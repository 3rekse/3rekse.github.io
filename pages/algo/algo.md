---
layout: cover
title: Pagina 1
level: 1
---


Algoritmi di apprendimento
ATTRAVERSO
Programmazione e risoluzione di puzzle

---
layout:
title: Pagina 2
level: 3
---

Benvenuto!

1. Le sfide di programmazione ti chiedono di implementare l'algoritmi

che incontrerai in uno dei linguaggi di programmazione
che supportiamo: C, C ++, Java, JavaScript, Python, Scala, C#,
Haskell, Ruby e Rust

2. Gli enigmi algoritmici 

Ti forniscono un modo divertente per "inventare" ed avere le idee algoritmiche chiave per la soluzione!
Anche se non riesci a risolverne alcuni problemi, il tempo non andrà perso perché apprezzerai meglio la
bellezza e potere degli algoritmi.

3. Comprensione di un argomento prima di passare al prossimo

4. Fermarsi e pensare e contestare

---
layout:
title: Pagina 3
level: 3
---

Attraverso la programmazione per la risoluzione di engmi apprenderemo gli Algoritmi


---
layout:
title: Pagina 6
level: 3
---

Contenuti

Sfide di programmazione di algoritmi per risolvere engmi

1. Algoritmi e complessità
Cos'è un algoritmo?
Pseudocodi
Problema rispetto all'istanza del problema
Algoritmi corretti contro errati
Algoritmi veloci contro lenti
Big-O notation
2. Tecniche di progettazione dell'algoritmo
Algoritmi di ricerca esaustivi
Algoritmi di ramo e rilegati
Algoritmi avidi
Algoritmi di programmazione dinamica
Algoritmi ricorsivi
Algoritmi di divisione e conquista
Algoritmi randomizzati
3. Sfide di programmazione
Somma di due cifre
Prodotto massimo a coppie
Algoritmo ingenuo
Algoritmo veloce
Test e debug

---
layout:
title: Pagina 7
level: 3
---

Puoi dirmi quale errore ho fatto?
Test di stress
Algoritmo ancora più veloce
Un algoritmo più compatto
Risolvere una sfida di programmazione in cinque semplici passaggi
Dichiarazione del problema di lettura
Progettazione di un algoritmo.
Implementazione di un algoritmo
Test e debug
Buone pratiche di programmazione
Riscaldamento algoritmico
Numero di fibonacci.
Ultima cifra del numero di Fibonacci
Massimo comun divisore
Minimo comune multiplo
Numero di Fibonacci di nuovo.
Ultima cifra della somma dei numeri di Fibonacci

Ultima cifra della somma dei numeri di Fibonacci
Algoritmi avidi
Cambio di moneta 
Valore massimo del bottino
Entrate della pubblicità massima
Raccolta delle firme
Numero massimo di premi
Stipendio massimo
Dividere e conquistare
Ricerca binaria
Elemento a maggioranza
Miglioramento di QuickSort
Numero di inversioni
Organizzare una lotteria

---
layout: 
title: Pagina 8
level: 3
---

Programmazione dinamica

Il denaro cambia di nuovo
Calcolatore primitivo
Modifica la distanza
La più lunga successione comune di due sequenze.....
La più lunga successione comune di tre sequenze
7.6
Quantità massima di oro...................107
7.7
Souvenir di partizionamento
.....................109
7.8
Valore massimo di un'espressione aritmetica........111
Appendice
113
Flag di compilatore.............................113
Domande frequenti .....................114



---
layout:
title: Pagina 10
level: 3
---

Ho scoperto che non capisco le cose a meno che non provo a programmarle.
Come implementare Algoritmi, l'abilità informatica cruciale.

---
layout:
title: Pagina 11
level: 3
---

X
Su questo libro
guasti con noi.
Quando uno studente provoca una rottura dell'apprendimento, quello studente ha bisogno
mediare l'aiuto per procedere.I libri di testo tradizionali non forniscono
Tale aiuto, ma il nostro sistema di classificazione automatizzato descritto in questo MOOC
Il libro fa!Gli algoritmi sono una disciplina unica nella capacità degli studenti di
Il programma offre l'opportunità di controllare automaticamente la propria conoscenza
bordo attraverso le sfide di codifica.Queste sfide di codifica sono di gran lunga superiori
ai quiz tradizionali che controllano a malapena se uno studente si è addormentato.In-
atto, per implementare un algoritmo complesso, lo studente deve possedere un profondo
Comprensione delle sue idee algoritmiche sottostanti.
Crediamo che gran parte della classificazione in migliaia di algoritmi
I corsi tenuti in varie università ogni anno possono essere consolidati
Un singolo sistema automatizzato disponibile in tutte le università.Non è sfuggito
La nostra attenzione che molti professori che insegnano algoritmi hanno implementato
i loro sistemi su misura per la classificazione dei programmi degli studenti, un illuso
trazione di inefficienza accademica e mancanza di cooperazione tra vari
istruttori.Il nostro obiettivo è costruire un repository di programmazione algoritmica
sfide, permettendo così ai professori di concentrarsi sull'insegnamento.Abbiamo già
investito migliaia di ore nella costruzione di un tale sistema e migliaia
Gli studenti nei nostri MOOC lo hanno testato.Di seguito ci descriviamo con successo come funziona.
Quando affronti una sfida di programmazione, il tuo obiettivo è implementare
Un algoritmo veloce e di memoria e ﬃ ciente per la sua soluzione.Programma di risoluzione
Le sfide di Ming ti aiuteranno a comprendere meglio vari algoritmi e
può anche farti ottenere un lavoro poiché molte aziende ad alta tecnologia chiedono ai candidati
Per risolvere le sfide di programmazione durante le interviste.I tuoi implementari
la tazione verrà controllata automaticamente rispetto a molti test attentamente selezionati
Per verificare che produca sempre una risposta corretta e si adatta al tempo
e i vincoli di memoria.Il nostro sistema ti insegnerà a scrivere programmi che
Lavora correttamente su tutti i nostri set di dati di test piuttosto che su alcuni di essi.Questo
è un'abilità importante dal momento che non è riuscito a testare a fondo i tuoi programmi
a bug non rilevati che frustrano il tuo capo, i tuoi colleghi e, la maggior parte
È importante sottolineare che gli utenti dei tuoi programmi.
Forse ti stai chiedendo perché ci sono volute migliaia di ore per svilupparli
un sistema.Innanzitutto, abbiamo dovuto costruire un compendio di guasti all'apprendimento
Per ogni sfida di programmazione, 10-15 errori più frequenti che si stanno
Le ammaccature fanno mentre lo risolvono.Successivamente, abbiamo dovuto sviluppare casi di test
Per ogni ripartizione dell'apprendimento in ogni sfida di programmazione, oltre 20.000
Test dei casi per solo 100 sfide di programmazione nella nostra specializzazione.

---
layout:
title: Pagina 12
level: 3
---

Su questo libro
xi
Ti invitiamo a iscriverti ai nostri algoritmi e alle strutture di dati
Specializzazione sul programma Coursera o MicroSters su EDX e avvia in
teract con migliaia di studenti di talento da tutto il mondo che
sono algoritmi di apprendimento.Grazie per esserti unito a noi!

---
layout: 
title: Pagina 13
level: 3
---

Sfide di programmazione Enigmi

Sfide :
1. Somma di due cifre 2 + 3 = 5
2. Massimo Prodotto a coppie
5 6 2 7 4 5 30 10 35 20 6 30 12 42 24
2 10 12
7
4
7 35 42 14
28
4 20 24 8 28
3. Numero di fibonacci
1
1
2
3
5

Ultima cifra
di Fibonacci
Numero
F170 = 150804340016
807970735635
273952047185
4. Più grande
Divisore comune MCD
10
2
6
5. Minimo Comune Multiplo
30
2
3
5
6
15
10
6. Fibonacci
Numero di nuovo
FN Mod 3
0
0
1
1eno
1
1
2
2
3
0
5
2
8
2
13
1
7. Somma di
Numeri di fibonacci
1 + 1 + 2 + 3 + 5 + 8 = 20
Somma parziale di
Numeri di fibonacci
2 + 3 + 5 + 8 + 13 = 31
8. Cambio di moneta
¢ 1
¢ 5
¢ 10
9. Valore massimo
del bottino
Massimo
Annuncio
Reddito
clic
prezzi
30
20
10
5
3
2
Raccolta
Firme
Massimo
Numero di premi
8
1
2
5
Stipendio massimo
Riprendere
Ricerca binaria
1
3
7
8
9 12 15
1
3
7
8
9 12 15
1
3
7
8
9 12 15
Elemento a maggioranza
Miglioramento
Quicksort
Numero di
Inversione
3
2
5
9
4
Organizzare
una lotteria
1
0
2
1
Punti più vicini
Soldi
Cambiare di nuovo
¢ 1
¢ 3
¢ 4
Calcolatore primitivo
1
+1
× 2
× 3
Modifica la distanza
corto
Hort
porta
porti
Più lungo comune
Successivamente di
Due sequenze
7
2
9
3
1
5
9
4
2
8
1
3
9
7
Più lungo comune
Successivamente di
Tre sequenze
8
3
2
1
7
3
8
2
1
3
8 10 7
6
8
3
1
4
7
Massimo
Quantità di oro
Partizionamento
Souvenir
3
6
4
1
9
6
9
1
Valore massimo
di un arith-
espressione metica
((8 −5) × 3) = 9
(8 - (5 × 3)) = −7

---
layout: 
title: Pagina 14
level: 3
---


Sfide di programmazione e puzzle algoritmici
XIII
Sei anche invitato a risolvere i seguenti puzzle algoritmici disponibili
in grado di http://dm.compciclub.ru/app/list:
7 9 4 5 3 1 6 2 8
Ordinamento del libro.Riorganizzare i libri sullo scaffale (in aumento
Ordine delle altezze) utilizzando il numero minimo di swap.
Colorazione della mappa.
Usa il numero minimo di colori in modo tale da
Ai paesi vicini sono assegnati diversi colori e ciascuno
A Paese viene assegnato un singolo colore.
Otto regine.Metti otto regine sulla scacchiera in modo tale che
Non ci si attaccano due regine (una regina può muovere l'orizzonte
Tally, verticalmente o diagonale).
Cricca trova.
Trova il più grande gruppo di amici comuni
(Ogni coppia di amici è rappresentata da un bordo).
Hanoi Towers.Sposta tutti i dischi da un PEG a un altro usando
un numero minimo di mosse.In una sola mossa, puoi muoverti
Un disco superiore da un piolo a qualsiasi altro piolo ha fornito a te
Non posizionare un disco più grande sulla parte superiore di un disco più piccolo.
Gioco icosiano.Trova un ciclo visitando ogni nodo esattamente una volta.
Puzzle Guarini.Scambia i luoghi dei cavalieri bianchi e
I Black Knights.Due cavalieri non sono autorizzati ad occupare il
Stessa cella della scacchiera.
Assegnazione della stanza.
Posiziona ogni studente in uno dei suoi
stanze preferibili in un dormitorio in modo che ogni stanza sia occupata
da un singolo studente (le stanze preferibili sono mostrate dai bordi).

---
layout: 
title: Pagina 15
level: 3
---


xiv
Sfide di programmazione e puzzle algoritmici
Costruzione degli alberi.Rimuovere il numero minimo di bordi
Dal grafico per renderlo aciclico.
1
1
2
0
?
?
?
?
?
?
?
?
?
?
?
?
Numero di percorsi.Scopri quanti percorsi ci sono per ottenere
dal cerchio in basso a sinistra a qualsiasi altro cerchio e posizionalo
numero all'interno del cerchio corrispondente.
Quadrati in bianco e nero.
Usa il numero minimo di
Domande "Qual è il colore di questo quadrato?"
per trovare due
quadrati vicini di diversi colori.Il quadrato più a sinistra
è bianco, il quadrato più a destra è nero, ma i colori di tutti
Altri quadrati sono sconosciuti.
21
domande
Twenty One Domande Game.Trova un numero intero sconosciuto 1 ≤
x ≤n ponendo il numero minimo di domande "è x = y?"
(per qualsiasi 1 ≤y ≤n).Il tuo avversario risponderà o "sì" o
"X <y", o "x> y."
1
+1
× 2
× 3
Calcolatrice antica.Trova il numero minimo di opera
le zioni necessarie per ottenere un numero intero positivo n dal numero intero 1 US-
ing solo tre operazioni: aggiungi 1, moltiplica per 2 o moltiplica
di 3.
Linee della metropolitana.Stai pianificando un sistema di metropolitana in cui il
Le linee della metropolitana non devono attraversare.Puoi collegare ogni coppia di
Le cinque stazioni tranne una singola coppia?
Due Rocks Game.Ci sono due pile di dieci rocce.In ciascun
gira, tu e il tuo avversario potete prendere una roccia da
una sola pila o una roccia da entrambe le pile.
Il tuo avversario
si muove prima e il giocatore che prende l'ultimo rock vince il
gioco.Progetta una strategia vincente.
Tre Rocks Game.Ci sono due pile di dieci rocce.In ciascun
Gira, tu e il tuo avversario potete prendere fino a tre rocce.Tuo
L'avversario si muove prima e il giocatore che prende l'ultima roccia
Vince il gioco.Progetta una strategia vincente.

---
layout: 
title: Pagina 16
level: 3
---


Ciò che verrà
xv
Ciò che verrà
Guarda per le nostre future edizioni che copriranno i seguenti argomenti.
Strutture di dati
Array ed elenchi
Code prioritarie
Set disgiunti
Tavoli hash
Alberi di ricerca binari
Algoritmi sui grafici
Grafici decomposizione
Percorsi più brevi nei grafici
Alberi di spanning minimi
Percorsi più brevi nella vita reale
Algoritmi su stringhe
Matching pattern
Alberi su €
Array su uso
Burrows - trasformata di ruote
Algoritmi avanzati e complessità
Fluisce nelle reti
Programmi lineari
Problemi NP-completi
Far fronte alla completezza NP
Algoritmi di streaming

---
layout: 
title: Pagina 17
level: 3
---


XVI
Incontrare gli autori
Incontrare gli autori
Alexander S. Kulikov è un ricercatore senior
al Steklov Mathematical Institute of the Russian
Academy of Sciences, San Pietroburgo, Russia e
un docente presso il Dipartimento di Informatica e
Ingegneria all'Università della California, San Diego,
STATI UNITI D'AMERICA.Dirige anche il centro di informatica in
Saint Petersburg che fornisce un computer avanzato gratuito
corsi scientifici che completano gli universitari standard
Curricula Sity.Alexander detiene un dottorato di Ph. D.
Istituto matematico.I suoi interessi di ricerca includono
Algoritmi e teoria della complessità.
Ha scritto
corsi online "strutture di dati e algoritmi" e
“Introduzione alla matematica discreta per il computer
Scienza "che sono disponibili presso Coursera ed EDX.
Pavel Pevzner è Ronald R. Taylor Professore di Com-
Puter Science all'Università della California, SAN
Diego.
Ha un dottorato da Ph. D.
di fisica e tecnologia, Russia e onorario
Laurea presso la Simon Fraser University.È un Howard
Hughes Medical Institute Professor (2006), un as-
Sociation for Computing Machinery Fellow (2010),
Una società internazionale per la biologia computazionale
Fellow (2012) e membro del mondo accademico
Europaea (2016).
Ha scritto i libri di testo
Biologia molecolare computazionale:
Un algoritmico
Approccio (2000), un'introduzione alla bioinformatica
Algoritmi (2004) (congiuntamente con Neil Jones) e Bioin-
Algoritmi formatici: un approccio di apprendimento attivo
(2014) (congiuntamente con Phillip Compea).Ha scritto
Corsi online "Strutture e algoritmi di dati",
"Bioinformatica" e "Analizza il tuo genoma!"
Quello
sono disponibili presso Coursera ed EDX.

---
layout: 
title: Pagina 18
level: 3
---


Incontra il nostro co-co- se block == "# Pagina 19":
print ("Il Blocco è '# Pagina 19'")
Istruttori
XVII
Incontra i nostri co-istruttori online
Daniel Kane è professore associato all'università
della California, San Diego con un appuntamento congiunto
tra il Dipartimento di Informatica e
Ingegneria e Dipartimento di Matematica.Lui
ha diversi interessi in matematica e teorici
informatica, sebbene la maggior parte del suo lavoro sia in grado di
ampie categorie di teoria dei numeri, teoria della complessità,
o combinatoria.se block == "# Pagina 19":
print ("Il Blocco è '# Pagina 19'")

Michael Levin è professore associato a
IL
Dipartimento di Informatica della scuola superiore di
Economia, Mosca, Russia e dati principali
entist presso lo Yandex.Market, Mosca, Russia.Ha anche
insegna algoritmi e strutture di dati presso lo Yandex
School of Data Analysis.
Neil Rhodes è docente nell'informatica e
Dipartimento di ingegneria dell'Università di Califor
Nia, San Diego e precedentemente un ingegnere di software Sta ﬀ
a Google.
Neil detiene un B.A.e M.S.al computer
Scienza da UCSD.Ha lasciato il dottorato di ricerca.programma a
UCSD per avviare un'azienda, software Palomar e speso
cinque anni di scrittura di software, libri sul software de-
Velopment e programmazione di progettazione e insegnamento
Corsi per mela e palmo.Ha insegnato algoritmi,
Apprendimento automatico, sistemi operativi, matematica discreta-
teoria ematica, automi e computabilità e
Ingegneria del software presso UCSD e Harvey Mudd
College a Claremont, California.

---
layout: 
title: Pagina 19
level: 3
---


XVIII
Riconoscimenti
Riconoscimenti
Questo libro è stato notevolmente migliorato dagli e ﬀ orti di un gran numero di indifes
Viduals, a cui dobbiamo un debito di gratitudine.
I nostri co-istruttori e partner nel crimine Daniel Kane, Michael Levin,
e Neil Rhodes ha investito innumerevoli ore nello sviluppo del nostro
Corsi di linea presso le piattaforme Coursera ed EDX.
Centinaia di migliaia di nostri studenti online hanno fornito preziosi feed-
Back che ha portato a molti miglioramenti nei nostri MOOC e questo libro MOOC.
In particolare, siamo grati ai mentori della cassetta degli attrezzi algoritmici
Classe a Coursera: Ayoub Falah, Denys Diachenko, Kishaan Jeeveswaran,
Irina Pinjaeva, Fernando Gonzales Vigil Richter e Gabrio Secco.
Ringraziamo i nostri colleghi che ci hanno aiutato a preparare la programmazione
Sfide: Maxim Akhmedov, Roman Andreev, Gleb Evstropov, Niko-
Lai Karpov, Sergey Poromov, Sergey Kopeliovich, Ilya Kornakov, Gennady
Korotkevich, Paul Melnichuk e Alexander Tiunov.
Siamo grati ad Anton Konev per aver guidato lo sviluppo di inter-
Puzzle attivi e Anton Belyaev e Kirill Banaru per chiedere aiuto
Alcuni dei puzzle.
Ringraziamo Alexey Kladov e Alexander Smal per l'aiuto con il "Buono
Pratiche di programmazione "sezione del libro.
Randall Christopher ha dato vita alla nostra idea per la copertina dei libri di testo.
Infine, le nostre famiglie ci hanno aiutato a preservare la nostra sanità mentale quando stavamo lavorando
ing su questo libro MOOC.
A. K. e P. P.
San Pietroburgo e San Diego
Dicembre 2017

---
layout: 
title: Algoritmi e complessità
level: 3
---

# Algoritmi e complessità
Come progettare e implementare algoritmi.

Risolvere una sfida di programmazione è uno dei modi migliori per comprendere il design di un algoritmo ed identificare le sue potenziali debolezze e risolverle.

## Cos'è un algoritmo? (In parole povere)
Un algoritmo è una sequenza di istruzioni che uno deve eseguire (ESECUTORE) per risolvere un problema ben formulato.

I problemi in termini di input e dei loro output e l'algoritmo
sarà il metodo per tradurre gli ingressi nelle uscite.Un pozzo-
Il problema formulato è inequivocabile e preciso, non lasciando spazio a mis-
interpretazione.
Dopo aver progettato un algoritmo, due domande importanti da porre sono:
"Funziona correttamente?"e "Quanto tempo ci vorrà?"Certamente
Non saresti soddisfatto di un algoritmo che è tornato corretto solo
Risultati metà del tempo o impiegarono 1000 anni per arrivare a una risposta.
1.2
Pseudocodi
Per capire come funziona un algoritmo, abbiamo bisogno di un modo per elencare il
passi che fa l'algoritmo, pur non essendo né troppo vago né troppo per-
mal.Useremo lo pseudocodice, uno scienziati informatici linguistici usano spesso
per descrivere gli algoritmi.Pseudocodie ignora molti dei dettagli che sono
richiesto in un linguaggio di programmazione, ma è più preciso e meno
Biguo, diciamo, una ricetta in un libro di cucina.
1.3
Problema contro l'istanza del problema
Un problema descrive una classe di compiti computazionali.Un'istanza problematica è
Un input particolare da quella classe.Per illustrare la differenza tra
Un problema e un'istanza di un problema, considera il seguente esempio.
Ti trovi in ​​una libreria che acquista un libro per $ 4,23 che paghi
1

---
layout: 
title: Pagina 21
level: 3
---


2
Capitolo 1. Algoritmi e complessità
per con una fattura da $ 5.Saresti dovuto a 77 centesimi di cambiamento e il cassiere
Ora prende una decisione su come lo ottieni.Saresti infastidito
a un film di 77 centesimi o 15 nichel e 2 centesimi, che solleva il
Domanda su come apportare il cambiamento nel modo meno fastidioso.La maggior parte dei cassieri
Cerca di ridurre al minimo il numero di monete restituite per una particolare quantità di
modifica.L'esempio di 77 centesimi rappresenta un'istanza del cambiamento
Problema, che descriviamo di seguito.
L'esempio di 77 centesimi rappresenta un'istanza del problema di modifica
Ciò presuppone che ci siano denominazioni d rappresentate da un array
C = (C1, C2, ..., CD).Per semplicità, supponiamo che le denominazioni siano
dato in un ordine di valore decrescente.
Ad esempio, c = (25,10,5,1) per
Denominazioni degli Stati Uniti.
Cambia problema
Convertire una certa somma di denaro in una determinata denominazioni, usando il più piccolo
possibile numero di monete.
Input: un denaro intero e una serie di denominazioni D C =
(C1, C2, ..., CD), in ordine decrescente di valore (C1> C2> ··>> CD).
Output: un elenco di interi D i1, i2, ..., id tale che C1 · i1 + c2 · i2 +
··· + cd · id = denaro e i1 + i2 + ··· + id è il più piccolo possibile.
L'algoritmo utilizzato dai cassieri di tutto il mondo per risolverlo
Il problema è semplice:
Cambiamento (denaro, c, d):
mentre denaro> 0:
moneta ← moneta con la più grande denominazione che non supera il denaro
Dare moneta con moneta di denominazione al cliente
denaro ← denaro −coin
Ecco una versione più veloce del cambiamento:
Cambiamento (denaro, c, d):
r ← denaro
per k da 1 a d:
IK ← ⌊r
ck ⌋
r ← r −ck · ik
return (i1, i2, ..., id)

---
layout: 
title: Pagina 22
level: 3
---


1.4.Algoritmi corretti contro errati
3
1.4
Algoritmi corretti contro errati
Diciamo che un algoritmo è corretto quando traduce ogni istanza di input
nell'output corretto.Un algoritmo non è corretto quando c'è almeno
Un'istanza di input per la quale l'algoritmo fornisce un output errato.
Il cambiamento è un algoritmo errato!Supponiamo che tu stia cambiando 40 centesimi
in monete con denominazioni di C1 = 25, C2 = 20, C3 = 10, C4 = 5 e
C5 = 1. La modifica restituirebbe erroneamente 1 trimestre, 1 centesimo e 1 nichel,
Invece di 2 pezzi da venti centesimi.Per quanto inventato possa sembrare, nel 1875
Una moneta da venti centesimi esisteva negli Stati Uniti.Quanto possiamo essere sicuri
Il cambiamento restituisce il numero minimo di monete per la moderna denomini
nazioni o per denominazioni in qualsiasi altro paese?
Per correggere l'algoritmo di cambiamento, potremmo considerare ogni possibile
Combinazione di monete con denominazioni C1, C2, ..., CD che aggiunge denaro,
e restituire la combinazione con il minor numero.
Dobbiamo solo con-
Combinazioni sider con i1 ≤money/c1 e i2 ≤money/c2 (in generale, ik
non dovrebbe superare il denaro/ck), perché altrimenti torneremmo
una somma di denaro più grande del denaro.Lo pseudocodico in basso utilizza il
Simbolo P che sta per somma: PM
i = 1 ai = a1 +a2 +··· +am.Il pseu-
Docode usa anche la nozione di "in ﬁ writy" (indicato come ∞) come valore iniziale
per il più piccolo Numerofcoins;Esistono diversi modi per eseguirlo
In un vero computer, ma i dettagli non sono importanti qui.
BRUTEFORCECHANGE (denaro, c, d):
Piccole NumberOfCoins ← ∞
Per ogni (i1, ..., id) da (0, ..., 0) a (denaro/c1, ..., denaro/cd)
ValueOfCoins ← PD
k = 1 ik · ck
se valowoofcoins = m:
NumberOfCoins = pd
k = 1 ik
Se NumberOfCoins <PiccoleNumberOfCoins:
Piccole NumberOfCoins ← NumberOfCoins
Cambia ← (i1, i2, ..., id)
Return Change
La seconda riga itera su ogni combinazione fattibile (i1, ..., id) di
gli indici D e si fermano quando ha raggiunto (denaro/c1, ..., denaro/cd).
Come facciamo a sapere che BruteForceChange non suona dal
Lo stesso problema del cambiamento ha fatto, vale a dire che genera risultati errati

---
layout: 
title: Pagina 23
level: 3
---


4
Capitolo 1. Algoritmi e complessità
Per qualche istanza di input ??Poiché BruteforceChange esplora tutti i fattibili
combinazioni di denominazioni, alla fine si imbatterà in un ottimale
soluzione e registralo come tale nell'array di cambiamento.Qualsiasi combinazione di
Le monete che si aggiungono a m devono avere almeno tante monete quanto il com- ottimale
binazione, quindi bruteforcechange non sovrascriverà mai il cambiamento con un sub-
soluzione ottimale.
Finora abbiamo risposto solo uno dei due importanti algoritmici
Domande ("funziona?", Ma non "quanto tempo ci vorrà?").
Fermati e pensa.Quanto è veloce BruteForceChange?
1.5
Algoritmi veloci contro lenti
I computer reali richiedono un certo periodo di tempo per eseguire un'operazione
come l'aggiunta, la sottrazione o il test delle condizioni in un circuito.
Un supercomputer potrebbe richiedere 10-10 secondi per eseguire un'aggiunta, mentre
Un calcolatore potrebbe richiedere 10-5 secondi.Supponiamo di avere un computer
Ci sono voluti 10-10 secondi per eseguire un'operazione elementare come ad-
condizione e che sapevi quante operazioni un particolare algoritmo
si esibirebbe.Potresti stimare il tempo di esecuzione dell'algoritmo
semplicemente prendendo il prodotto del numero di operazioni e del tempo
per operazione.Tuttavia, i computer migliorano costantemente, portando a
un tempo decrescente per operazione, quindi la nozione di tempo di esecuzione
presto essere obsoleto.Piuttosto che calcolare il tempo di esecuzione di un algoritmo
ogni computer, facciamo affidamento sul numero totale di operazioni che al-
Il goritmo si esibisce per descrivere il suo tempo di esecuzione, poiché questo è un attributo
dell'algoritmo e non un attributo del computer che ti capita di essere
usando.
Sfortunatamente, determinare quante operazioni un algoritmo lo farà
esibirsi non è sempre facile.Se sappiamo come calcolare il numero di
Operazioni di base che un algoritmo esegue, quindi abbiamo una base per
Parelo contro un diverso algoritmo che risolve lo stesso problema.Piuttosto
che contare noiosamente ogni moltiplicazione e aggiunta, possiamo esibirci
questo confronto ottenendo una comprensione di alto livello della crescita di
Il conteggio delle operazioni di ogni algoritmo aumenta la dimensione dell'ingresso.
Supponiamo che un algoritmo A esegui operazioni 11n3 su un input di
Size N e un algoritmo B risolve lo stesso problema in 99N2 + 7 Opera-

---
layout: 
title: Pagina 24
level: 3
---


1.5.Algoritmi veloci contro lenti
5
zioni.Quale algoritmo, A o B, è più veloce?Sebbene A possa essere più veloce di B
Per un po 'di N (ad esempio, per n tra 0 e 9), B diventerà più veloce per
grande N (ad esempio, per tutti n> 10).Poiché N3 è, in un certo senso, una "crescita più veloce"
funzione di N2 rispetto a N, le costanti 11, 99 e 7 no
ect etta la competizione tra i due algoritmi per grandi n.Ci riferiamo
a A come algoritmo cubico e a B come algoritmo quadratico e dirlo
A è meno e ﬃ ciente di b perché esegue più operazioni per risolvere il
stesso problema quando n è grande.Quindi, saremo spesso in qualche modo imprecisi
Quando conteggiamo le operazioni di un algoritmo, il comportamento degli algoritmi
Piccoli input non importa.
Stimiamo che il numero di operazioni prenderà BruteforceChange
su un'istanza di input di m centesimi e denominazioni (C1, C2, ..., CD).A cal-
Cula il numero totale di operazioni nel ciclo per loop, possiamo prendere l'ap-
numero prossima di operazioni eseguite in ogni iterazione e moltiplica
Questo dal numero totale di iterazioni.Dato che ci sono approssimativamente
soldi
C1
× denaro
C2
× ··· × denaro
CD
iterazioni, il loop si comporta nell'ordine di d × moneyd
Operazioni C1C2 ··· CD,
che sminuisce le altre operazioni dell'algoritmo.
Questo tipo di algoritmo viene spesso definito un algoritmo esponenziale
Contrariamente ai quadratici, cubici o altri algoritmi polinomiali.L'espressione
Sion per il tempo di esecuzione degli algoritmi esponenziali include un termine come
nd, dove n e d sono parametri del problema (cioè n e d possono delibare
essere reso arbitrariamente grande cambiando l'input all'algoritmo),
Mentre il tempo di esecuzione di un algoritmo polinomiale è delimitato da un termine
Come NK dove K è una costante non correlata alla dimensione di alcun parametro.
Per esempio,
Un algoritmo con tempo di esecuzione N1 (lineare),
N2
(quadratico), N3 (cubico) o addirittura N2018 è polinomio.Naturalmente, un algo
Il ritmo con il tempo di esecuzione N2018 non è molto pratico, forse meno di
Alcuni algoritmi esponenziali, e molto e ﬀ ort nell'informatica vanno
nella progettazione di algoritmi polinomiali più veloci.Poiché D può essere
grande quando l'algoritmo viene chiamato con un lungo elenco di denominazioni (ad es.
C = (1,2,3,4,5, ..., 100)), vediamo che BruteForceChange può prendere un molto
molto tempo da eseguire.

---
layout: 
title: Pagina 25
level: 3
---


6
Capitolo 1. Algoritmi e complessità
1.6
Big-O notation
Gli informatici usano la notazione Big-O per descrivere in modo conciso la run-
tempo ning di un algoritmo.Se diciamo che il tempo di esecuzione di un algoritmo
è quadratico o O (n2), significa che il tempo di esecuzione dell'algoritmo
Un input di dimensioni n è limitato da una funzione quadratica di n.Quel limite può
essere 99,7n2 o 0,001n2 o 5n2 + 3.2n + 99993;il fattore principale che descrive
Il tasso di crescita del tempo di esecuzione è il termine che cresce più velocemente con
Rispetto a N, ad esempio N2 rispetto a termini come 3.2N o 99993.
Tutte le funzioni con un termine principale di N2 hanno più o meno lo stesso tasso di
Crescita, quindi li raggruppiamo in una classe che chiamiamo O (N2).Il di ﬀ er-
Ence nel comportamento tra due funzioni quadratiche in quella classe, diciamo 99.7n2
e 5n2 + 3.2n + 99993, è trascurabile rispetto alla differenza in
comportamento tra due funzioni in diverse classi, diciamo 5n2 + 3.2n e
1.2n3.Naturalmente, 99.7n2 e 5n2 sono diverse funzioni e lo faremmo
Preferisci un algoritmo che porta le operazioni 5n2 a un algoritmo che prende
99.7n2.Tuttavia, gli informatici in genere ignorano la con-
Stant e presta attenzione solo al termine in più rapida crescita.
Quando scriviamo f (n) = O (n2), intendiamo che la funzione f (n) non lo fa
crescere più velocemente di una funzione con un termine principale di CN2, per una scelta adatta
della costante c.In linea con la sana dose di pessimismo verso
prestazioni di un algoritmo, misuriamo l'efficienza di un algoritmo come la sua
peggiore efficienza del caso, che è il più grande tempo che un algoritmo può
Prendi dato il peggior input possibile di una determinata dimensione.Il vantaggio di con-
Sidering la peggiore efficienza del caso di un algoritmo è che siamo garantiti
che il nostro algoritmo non si comporterà mai peggio della nostra stima del caso peggiore,
Quindi non siamo mai sorpresi o delusi.Quindi, quando deriviamo un big-o
Legato, è vincolato sul peggiore caso.

---
layout: 
title: Pagina 26
level: 3
---


Capitolo 2: tecniche di progettazione dell'algoritmo
Nell'ultimo mezzo secolo, gli informatici hanno scoperto che molti
Gli algoritmi condividono idee simili, anche se risolvono un problema molto diverso
Lems.Sembrano esserci relativamente poche tecniche di base che possono essere ap-
impugnati durante la progettazione di un algoritmo e ne copriamo alcuni più avanti
Varie sfide di programmazione in questo libro.Per ora ci menzioneremo
Le tecniche di progettazione dell'algoritmo più comuni, in modo che esempi futuri
può essere classificato in termini di metodologia di progettazione dell'algoritmo.
Per illustrare le tecniche di progettazione, considereremo molto semplice
Problema che affliggeva quasi tutti prima dell'era dei telefoni cellulari
Quando le persone usavano telefoni a cordone.Supponiamo che il tuo telefono cordless squilla,
Ma hai smarrito il telefono da qualche parte nella tua casa.Come faccio
Lo hai scoperto?Per complicare le cose, hai appena camminato a casa tua
Con un braccio di generi alimentari, ed è buio, quindi non puoi fare affidamento esclusivamente
sulla vista.
2.1
Algoritmi di ricerca esaustivi
Una ricerca esaustiva o una forza bruta, l'algoritmo esamina ogni possibile al-
Ternativo per trovare una soluzione particolare.Ad esempio, se hai usato il
Algoritmo di forza bruta per trovare il telefono che squilla, ignoreresti il
squillare il telefono, come se non potessi sentirlo e semplicemente camminare su ev-
Ery Square Inch della tua casa controllando se il telefono era presente.Voi
Probabilmente non sarebbe in grado di rispondere al telefono prima che smettesse di squillare
A meno che tu non sia stato molto fortunato, ma alla fine ti sarebbe garantito
trovare il telefono, non importa dove fosse.
BruteForceChange è un algoritmo di forza bruta e la nostra programmazione
Le sfide includono alcuni esempi aggiuntivi di tali algoritmi: questi
sono gli algoritmi più facili da progettare e talvolta funzionano per certi
problemi pratici.In generale, tuttavia, gli algoritmi della forza bruta sono troppo lenti
essere pratico per qualsiasi cosa tranne i più piccoli casi e dovresti al-
modi pensano come evitare gli algoritmi della forza bruta o come finirli
in versioni più veloci.
7

---
layout: 
title: Pagina 27
level: 3
---


8
Capitolo 2. Tecniche di progettazione dell'algoritmo
2.2
Algoritmi di ramo e rilegati
In alcuni casi, mentre esploriamo le varie alternative in una forza bruta
Algoritmo, scopriamo che possiamo omettere un gran numero di alternative,
Una tecnica che viene spesso chiamata ramo e rilegato.
Supponiamo che tu stia cercando in modo esaustivo il primo pavimento e ascoltato il
Telefono che squilla sopra la testa.Potresti immediatamente escludere la necessità
per cercare nel seminterrato o il primo piano.Cosa potrebbe aver richiesto tre ore
ora può prenderne uno, a seconda della quantità di spazio che puoi
escludere.
2.3
Algoritmi avidi
Molti algoritmi sono procedure iterative che scelgono tra una serie di
Alternative ad ogni iterazione.Ad esempio, un cassiere può visualizzare la modifica
Problema come una serie di decisioni che deve prendere: quale moneta (tra
D denominations) per restituire la prima, che torna secondo, e così via.Alcuni
Di queste alternative possono portare a soluzioni corrette mentre altre potrebbero non farlo.
Gli algoritmi avidi scelgono l'alternativa "più attraente" a ciascuno
Erazione, ad esempio, la più grande denominazione possibile.Nel caso del
Denominazioni statunitensi, cambio di quarti usati, poi dimetti, poi nichel e
Pennie finalmente (in quell'ordine) per apportare modifiche.Certo, l'abbiamo mostrato
questa avida strategia ha prodotto risultati errati quando alcuni nuovi denom
Sono state incluse le inazioni.
Nell'esempio del telefono, l'algoritmo avido corrispondente lo farebbe
basta andare a camminare nella direzione del suono del telefono fino a te
trovato.Il problema qui è che potrebbe esserci un muro (o un vaso fragile)
tra te e il telefono, impedendoti di trovarlo.Svolucro
inoltre, questo tipo di difficoltà si verificano spesso nella più realistica problema
Lems.In molti casi, un approccio avido sembrerà "ovvio" e naturale,
ma sarà sottilmente sbagliato.
2.4
Algoritmi di programmazione dinamica
Alcuni algoritmi rompono un problema in sottoproblemi più piccoli e usano il
Soluzioni dei sottoproblemi per costruire la soluzione di quella più grande.

---
layout: 
title: Pagina 28
level: 3
---


2.4.Algoritmi di programmazione dinamica
9
Durante questo processo, il numero di sottoproblemi può diventare molto grande,
e alcuni algoritmi risolvono ripetutamente lo stesso sottoproblema
Aumentare il tempo di esecuzione.La programmazione dinamica organizza computa
zioni per evitare i valori di ricompensa che già conosci, che spesso possono
Risparmia molto tempo.
Il problema del telefono che squilla non si presta a una proposta dinamica
Soluzione di Gramming, quindi consideriamo un diverso problema per illustrare il
tecnica.Supponiamo che invece di rispondere al telefono decidi di farlo
Gioca al gioco "Rocks" con due pile di rocce, diciamo dieci in ciascuna.In ciascun
Gira, un giocatore può prendere una roccia (da una pila) o due rocce
(uno da ogni pila).Una volta prese le rocce, vengono rimosse da
giocare.Il giocatore che prende l'ultimo rock vince il gioco.Fai il primo
mossa.Ti invitiamo a giocare a questo gioco usando il nostro puzzle interattivo.
Per trovare la strategia vincente per il gioco 10+10, possiamo costruire un Ta-
ble, che possiamo chiamare r, mostrato nella Figura 2.1.Invece di risolvere un problema
Con 10 rocce in ogni pila, risolveremo un problema più generale con n
rocce in una pila e m rocce nell'altra pila (il gioco N + M) dove
N e M sono numeri interi arbitrari non negativi.
Se il giocatore 1 può sempre vincere il gioco N+M, allora diremmo r (n, m) =
W, ma se il giocatore 1 non ha una strategia vincente contro un giocatore che sempre
fa le mosse giuste, scriviamo r (n, m) = L. computing r (n, m)
Per n e m arbitrari sembrano digeriti, ma possiamo basarci su val- più piccoli
ues.Alcuni giochi, in particolare R (0,1), R (1,0) e R (1,1), stanno chiaramente vincendo
Proposizioni per il giocatore 1 Poiché nella prima mossa, il giocatore 1 può vincere.Così,
Ci riempiamo di voci (1,1), (0,1) e (1,0) come W. Vedi Figura 2.1 (a).
Dopo che le voci (0,1), (1,0) e (1,1) sono riempite, si può provare a riempire
Altre voci.Ad esempio, nel caso (2,0), l'unica mossa quel giocatore 1
può dare letti al caso (1,0) che, come già sappiamo, è una vittoria
posizione per il suo avversario.Un'analisi simile si applica al caso (0,2),
portando alla tabella nella Figura 2.1 (b).
Nel caso (2,1), il giocatore 1 può fare tre diverse mosse che conducono
rispettivamente ai giochi di (1,1), (2,0) o (1,0).Uno di questi casi, (2,0),
porta a una posizione perdente per il suo avversario e quindi (2,1) è una vittoria
posizione.Il caso (1,2) è simmetrico a (2,1), quindi abbiamo mostrato la tabella
alla Figura 2.1 (c).
Ora possiamo riempire in r (2,2).Nel caso (2,2), il giocatore 1 può farne tre
mosse diverse che portano a voci (2,1), (1,2) e (1,1).Tutti questi
Le voci sono posizioni vincenti per il suo avversario e quindi R (2,2) = L,

---
layout: 
title: Pagina 29
level: 3
---


10
Capitolo 2. Tecniche di progettazione dell'algoritmo
0
1
2
3
4
5
6
7
8
9 10
0
W
1 W w
2
3
4
5
6
7
8
9
10
(UN)
0
1
2
3
4
5
6
7
8
9 10
0
W l
1 W w
2 l
3
4
5
6
7
8
9
10
(B)
0
1
2
3
4
5
6
7
8
9 10
0
W l
1 w w w
2 l w
3
4
5
6
7
8
9
10
(C)
0
1
2
3
4
5
6
7
8
9 10
0
W l
1 w w w
2 l w l
3
4
5
6
7
8
9
10
(D)
0
1
2
3
4
5
6
7
8
9 10
0
W l w l w l w l w l
1 w w w w w w w w w w w w w w
2 l w l w l w l w l w l
3 w w w w w w w w w w w w w w
4 L W L W L W L W L W L
5 w w w w w w w w w w w w w w
6 L W L W L W L W L W L
7 w w w w w w w w w w w w w w
8 L W L W L W L W L W L
9 w w w w w w w w w w w w w w
10 l w l w l w l w l w l
(e)
Figura 2.1: Tabella R per il gioco 10 + 10 Rocks.

---
layout: 
title: Pagina 30
level: 3
---


2.4.Algoritmi di programmazione dinamica
11
Vedere la Figura 2.1 (d).
Possiamo procedere in fase di riempimento in questo modo notando che per la voce
(i, j) per essere l, le voci sopra, in diagonale a sinistra e direttamente al
a sinistra, devono essere W. Queste voci ((I - 1, J), (I - 1, J - 1) e (I, J - 1) corrispondono
Alle tre possibili mosse che il giocatore 1 può fare.Vedere la Figura 2.1 (e).
L'algoritmo delle rocce determina se il giocatore 1 vince o perde.Se il giocatore 1
Vince in una partita N+M, Rocks restituisce W. Se il giocatore 1 perde, Rocks restituisce L.
Abbiamo introdotto una condizione iniziale artificiale, r (0,0) = l per semplificare il
pseudocodi.
Rocce (n, m):
R (0,0) ← l
per io da 1 a n:
Se r (i −1,0) = W:
R (i, 0) ← l
altro:
R (i, 0) ← W
per j da 1 a m:
se r (0, j −1) = w:
R (0, j) ← l
altro:
R (0, j) ← W
per io da 1 a n:
per j da 1 a m:
Se r (i −1, j −1) = w e r (i, j −1) = w e r (i −1, j) = w:
R (i, j) ← l
altro:
R (i, j) ← w
restituire r (n, m)
Un algoritmo più veloce per risolvere il puzzle si basa sul semplice pat-
stern in r e controlla se n e m sono entrambi uniformi, nel qual caso il giocatore
perde (vedi tabella sopra).
Fastrocks (N, M):
Se N e M sono entrambi anche:
restituire l
altro:
Ritorno w

---
layout: 
title: Pagina 31
level: 3
---


12
Capitolo 2. Tecniche di progettazione dell'algoritmo
Tuttavia, sebbene Fastrocks sia più efficiente delle rocce, può essere
Di € cult per modificarlo per giochi simili, ad esempio un gioco in cui ciascuno
Il giocatore può muoversi fino a tre rocce alla volta dalle pile.Questo è uno
Esempio in cui l'algoritmo più lento è più istruttivo di uno più veloce.
Pausa di esercizio.Gioca al gioco Tre Rocks usando il nostro puzzle interattivo
e costruire la tabella di programmazione dinamica simile alla tabella sopra
per questo gioco.
2.5
Algoritmi ricorsivi
La ricorsione è uno dei concetti algoritmici più onnipresenti.Semplicemente, un
L'algoritmo è ricorsivo se si chiama.
Le torri di Hanoi puzzle sono costituite da tre pioli, da cui etichettamo
Da sinistra a destra come 1, 2 e 3 e una serie di dischi di raggio decrescente,
ciascuno con un buco al centro.I dischi sono inizialmente impilati a sinistra
PEG (PEG 1) in modo che i dischi più piccoli siano in cima a quelli più grandi.Il gioco è
Gioco spostando un disco alla volta tra i pioli.Ti è permesso solo
posizionare i dischi più piccoli sopra quelli più grandi e qualsiasi disco può andare su un
PEG vuoto.Il puzzle viene risolto quando tutti i dischi sono stati spostati
da PEG 1 a PEG 3. Prova le nostre torri interattive di puzzle per figurare
Come spostare tutti i dischi da un piolo all'altro.
Torri di Hanoi Problema
Output Un elenco di mosse che risolve le torri di Hanoi.
Input: un numero intero n.
Output: una sequenza di mosse che risolvono le torri a dischi n.
Puzzle di Hanoi.
Risolvere il puzzle con un disco è facile: sposta il disco a destra
PEG.Il puzzle a due dischi non è molto più difficile: sposta il piccolo disco su
piolo medio, quindi il grande disco sul piolo destro, quindi il piccolo disco al
PEG a destra per riposare sopra il disco grande.
Il puzzle a tre dischi è un po 'più difficile, ma la seguente sequenza
di sette mosse lo risolve:

---
layout: 
title: Pagina 32
level: 3
---


2.5.Algoritmi ricorsivi
13
1. Spostare il disco da PEG 1 a PEG 3
2. Spostare il disco da PEG 1 a PEG 2
3. Spostare il disco da PEG 3 a PEG 2
4. Spostare il disco da PEG 1 a PEG 3
5. Spostare il disco da PEG 2 a PEG 1

---
layout: 
title: Pagina 33
level: 3
---


14
Capitolo 2. Tecniche di progettazione dell'algoritmo
6. Sposta il disco da PEG 2 a PEG 3
7. Spostare il disco da PEG 1 a PEG 3
Ora scopriremo quanti passaggi sono necessari per risolvere un quattro-
puzzle del disco.Non puoi completare questo gioco senza spostare il più grande
disco.Tuttavia, al fine di spostare il disco più grande, abbiamo dovuto spostare tutti tutti
I dischi più piccoli a un piolo vuoto.Se avessimo quattro dischi anziché tre,
Quindi dovremmo prima spostare i primi tre in un piolo vuoto (7 mosse),
Quindi sposta il disco più grande (1 mossa), quindi sposta nuovamente i tre dischi da
il loro piolo temporaneo si poggia sopra il disco più grande (altre 7 mosse).
L'intera procedura richiederà 7 + 1 + 7 = 15 mosse.
Più in generale, per spostare una pila di dimensioni N da sinistra a destra,
È necessario spostare una pila di dimensioni n −1 da sinistra al PEG centrale,
e poi dal piolo centrale al piolo destro una volta che hai spostato il
N-th disco sul piolo destro.Per spostare una pila di dimensioni n -1 dal centro
A destra, è necessario spostare una pila di dimensioni n -2 dal centro a
la sinistra, quindi sposta il disco (n-1) -th a destra, quindi sposta lo stack
di dimensioni n −2 da sinistra a destra e così via.
A prima vista, le torri del problema di Hanoi sembrano diverse.Tuttavia,
Il seguente algoritmo ricorsivo risolve il problema delle torri di Hanoi
Solo 9 righe!

---
layout: 
title: Pagina 34
level: 3
---


2.5.Algoritmi ricorsivi
15
Hanoitowers (N, Frompeg, Topeg)
Se n = 1:
Output "Sposta disco da PEG da PEG a PEG TOPEG"
ritorno
unusedpeg ← 6 −frompeg −topeg
Hanoitowers (n −1, Frompeg, UnusedPeg)
Output "Sposta disco da PEG da PEG a PEG TOPEG"
Hanoitowers (N −1, UnusedPeg, Topeg)
ritorno
Le variabili dapeg, topeg e unusedpeg si riferiscono ai tre di ﬀ er-
PEGS ENT in modo che Hanoitowers (n, 1,3) sposta n dischi dal primo PEG a
il terzo piolo.La variabile non utilizzata rappresenta quale dei tre pioli
può servire da destinazione temporanea per i primi dischi N −1.Notare che
dapeg + topeg + unusedpeg è sempre uguale a 1 + 2 + 3 = 6, quindi il valore
della variabile non utilizzata, può essere calcolato come 6 −frompeg −topeg.Tavolo
sotto mostra il risultato di 6 −frompeg −topeg per tutti i possibili valori di
dapeg e topeg.
Frompeg
Topeg
Unusedpeg
1
2
3
1
3
2
2
1
3
2
3
1
3
1
2
3
2
1
Dopo aver calcolato UnusedPeg come 6 −frompeg −Topeg, le dichiarazioni
Hanoitowers (n −1, Frompeg, UnusedPeg)
Output "Sposta disco da PEG da PEG a PEG TOPEG"
Hanoitowers (N −1, UnusedPeg, Topeg)
ritorno
Risolvi il problema più piccolo di spostare la pila di dimensioni n −1 per prima
spazio temporaneo, spostando il disco più grande, quindi spostando N -1
dischi di manutenzione alla destinazione finale.Si noti che non dobbiamo specificare
quale disco il giocatore dovrebbe spostarsi da dapeg a topeg: è sempre il
Top disco attualmente risiede da Frompeg che viene spostato.

---
layout: 
title: Pagina 35
level: 3
---


16
Capitolo 2. Tecniche di progettazione dell'algoritmo
Sebbene la soluzione Hanoi Tower possa essere espressa in sole 9 righe di
Pseudocodi, richiede un tempo sorprendentemente lungo per essere eseguita.Per risolvere un file
La torre del disco richiede 31 mosse, ma per risolvere una torre di cento dischi farebbe
richiedono più mosse di quante ci siano atomi sulla terra.La rapida crescita di
Il numero di mosse richieste da Hanoitowers è facile da vedere notando
che ogni volta che Hanoitowers (n, 1,3) viene chiamato, si chiama due volte per N - 1,
che a sua volta innesca quattro richieste per n -2 e così via.
Possiamo illustrare questa situazione in un albero di ricorsione,
che è
mostrato nella Figura 2.2.
Una chiamata a Hanoitowers (4,1,3)
chiama Hanoitowers (3,1,2) e Hanoitowers (3,2,3);
ognuno di questi
Risultati
In
chiamate
A
Hanoitowers (2,1,3),
Hanoitowers (2,3,2)
E
Hanoitowers (2,2,1), Hanoitowers (2,1,3) e così via.Ogni chiamata al file
la subroutine hanoitowers richiede un po 'di tempo, quindi vorremmo
Per sapere quanto tempo impiegherà l'algoritmo.
Per calcolare il tempo di esecuzione di Hanoitowers di dimensioni n, denotiamo il
Numero di mosse di disco che Hanoitowers (N) esegue come t (n) e avviso
Che la seguente equazione detiene:
T (n) = 2 · t (n −1) + 1.
A partire da T (1) = 1, questa relazione di ricorrenza produce la sequenza:
1,3,7,15,31,63,
e così via.Possiamo calcolare t (n) aggiungendo 1 a entrambi i lati e notando
T (n) + 1 = 2 · t (n −1) + 1 + 1 = 2 · (t (n −1) + 1).
Se introduciamo una nuova variabile, u (n) = t (n) + 1, allora u (n) = 2 · u (n −1).
Pertanto, abbiamo cambiato il problema nella seguente relazione di ricorrenza.
U (n) = 2 · u (n −1).
A partire da u (1) = 2, questo dà origine alla sequenza
2,4,8,16,32,64, ...
implicando che a u (n) = 2n e t (n) = u (n) −1 = 2n −1.
Così,
Hanoitowers (N) è un algoritmo esponenziale.

---
layout: 
title: Pagina 36
level: 3
---


2.5.Algoritmi ricorsivi
17
(4,1,3)
(3, 1, 2)
(2, 1, 3)
(1, 1, 2) (1, 2, 3)
(2, 3, 2)
(1, 3, 1) (1, 1, 2)
(3, 2, 3)
(2, 2, 1)
(1, 2, 3) (1, 3, 1)
(2, 1, 3)
(1, 1, 2) (1, 2, 3)
Figura 2.2: l'albero di ricorsione per una chiamata a Hanoitowers (4,1,3), che
Risolve le torri di Hanoi Problema della dimensione 4. In ogni punto dell'albero,
(I, J, K) sta per Hanoitowers (I, J, K).

---
layout: 
title: Pagina 37
level: 3
---


18
Capitolo 2. Tecniche di progettazione dell'algoritmo
2.6
Algoritmi di divisione e conquista
Un grosso problema potrebbe essere difficile da risolvere, ma due problemi che sono la metà
Le dimensioni possono essere significativamente più facili.In questi casi, dividi e conquista al-
I goritmi vanno bene facendo proprio questo: dividere il problema in più piccolo
sottoproblemi, risolvendo i sottoproblemi in modo indipendente e combinando il
Soluzioni di sottoproblemi in una soluzione del problema originale.IL
La situazione è generalmente più complicata di questa e dopo averlo separato
Problema nei sottoproblemi, un algoritmo di divisione e conquista di solito si divide
Questi sottoproblemi in sotto-problemi ancora più piccoli, e così via, fino a quando
Raggiunge un punto in cui non ha più bisogno di ricorrere.Un passo critico
In molti algoritmi di divisione e conquista è la ricombinazione delle soluzioni
Subrobles in una soluzione per un problema più grande.
Per dare un esempio di algoritmo di divisione e conquista, lo faremo
Considera il problema di smistamento:
Problema di smistamento
Ordina un elenco di numeri interi.
Input: un elenco di n numeri interi distinti a = (a1, a2, ..., an).
Produzione:
Elenco ordinato di numeri interi, cioè un riordino b =
(B1, B2, ..., BN) di numeri interi di A tale che B1 <b2 <··· <bn.
Selectionsort è un semplice metodo iterativo per risolvere il problema di ordinamento
Lem.Prima trova l'elemento più piccolo in un e lo sposta al primo po '
sizioning scambiandolo con qualunque cosa accada nella prima posizione
(cioè, a1).Successivamente, trova il secondo elemento più piccolo in A e lo sposta
alla seconda posizione, di nuovo scambiando con A2.All'i-Thth Iteration,
Selectionsort trova l'elemento i-th più piccolo in a e lo sposta su
I-th Posizione.Questo è un approccio intuitivo all'ordinamento, ma non è il più veloce
uno.
Se a = (7,92,87,1,4,3,2,6), SelectionsTort (a, 8) prende quanto segue
Sette passaggi:
(7,92,87,1,4,3,2,6)
(1,92,87,7,4,3,2,6)
(1,2,87,7,4,3,92,6)
(1,2,3,7,4,87,92,6)

---
layout: 
title: Pagina 38
level: 3
---


2.6.Algoritmi di divisione e conquista
19
(1,2,3,4,7,87,92,6)
(1,2,3,4,6,87,92,7)
(1,2,3,4,6,7,92,87)
(1,2,3,4,6,7,87,92)
Mergesort è un esempio canonico di algo di smistamento di divisione e conquista
Ritmo che è molto più veloce di SelectionsTort.Cominciamo dal problema
di unire, in cui vogliamo combinare due elenchi ordinati List1 ed List2
in un unico elenco ordinato.
List1
2 5 7 8 |2 5 7 8 |2 5 7 8 |2 5 7 8 |2 5 7 8 |2 5 7 8
List2
3 4 6 |
3 4 6 |
3 4 6 |
3 4 6 |
3 4 6 |
3 4 6
SortedList 2
3
4
5
6
7 8
L'algoritmo di unione combina due elenchi ordinati in un unico elenco ordinato
in o (| list1 | + | list2 |) tempo mediante iterativamente la scelta del più piccolo rimanente
Elemento in List1 e List2 e spostandolo nell'elenco ordinato in crescita.
Unisci (List1, List2):
Elenco vuoto ← Elenco vuoto
Mentre sia List1 che List2 non sono vuoti:
Se l'elemento più piccolo in List1 è più piccolo dell'elemento più piccolo in List2
Sposta l'elemento più piccolo da List1 alla fine di SortedList
altro:
Sposta l'elemento più piccolo da List2 alla fine di SortedList
Spostare qualsiasi elemento rimanente da List1 o List2 alla fine di SortedList
Restituisce SortedList
Unire sarebbe utile per ordinare un elenco arbitrario se sapessimo come farlo
Dividi un elenco arbitrario (Unsorted) in due elenchi di mezza dimensioni già ordinati.
Tuttavia, può sembrare che siamo tornati a dove abbiamo iniziato, tranne ora
Dobbiamo ordinare due liste più piccole invece di una grande.Eppure ordinarci due
Elenchi più piccoli è un problema algoritmico preferibile.Per capire perché, conquista
Sider l'algoritmo Mergesort, che divide un elenco non desiderato in due
parti e quindi conquista in modo ricorsivo ogni problema di smistamento più piccolo prima
Uscire le liste ordinate.

---
layout: 
title: Pagina 39
level: 3
---


20
Capitolo 2. Tecniche di progettazione dell'algoritmo
Mergesort (elenco):
Se l'elenco è costituito da un singolo elemento:
Elenco di restituzione
Firsthalf ← Prima metà dell'elenco
Secondhalf ← Seconda metà dell'elenco
SortedFirsthalf ← Mergesort (Firsthalf)
SortedSecondhalf ← Mergesort (SecondHalf)
SortedList ← Merge (SortedFirsthalf, SortedSecondhalf)
Restituisce SortedList
Fermati e pensa.Qual è il runtime di Mergesort?
La Figura 2.3 mostra l'albero di ricorsione di Mergesort, costituito da log2 n
livelli, dove n ha la dimensione dell'elenco originale non corto.A livello inferiore,
dobbiamo unire due elenchi ordinati di circa n/2 elementi ciascuno
Quiring O (n/2+n/2) = o (n) tempo.Al livello più alto successivo, dobbiamo unire
Quattro elenchi di elementi N/4, che richiedono O (N/4 + N/4 + N/4 + N/4) = O (N).
Questo modello può essere generalizzato: il livello i-Th contiene 2i elenchi, ciascuno
ing circa n/2i elementi e richiede tempo (n) per fondersi.Da
Ci sono livelli di log2 N nell'albero di ricorsione, Mergesort richiede O (Nlog2 N)
Runtime in generale, che offre un accelerato su un algo di ordinamento O (N2) ingenuo
Ritmo.
2.7
Algoritmi randomizzati
Se ti capita di avere una moneta, prima ancora di iniziare a cercare il
Telefono, potresti lanciarlo per decidere se vuoi iniziare la tua ricerca
il primo piano se la moneta si presenta alla testa o sul secondo pavimento se la moneta
arriva a coda.Se ti capita anche di avere un dado, dopo aver deciso il
Secondo pavimento della tua dimora, potresti lanciarlo per decidere in quale dei
Sei stanze sul secondo piano per iniziare la tua ricerca.Anche se lancia monete
E i dadi rotolanti possono essere un modo divertente per cercare il telefono, è certamente
non la cosa intuitiva da fare, né è affatto chiaro se ti dà qualcuno
vantaggio algoritmico rispetto a un algoritmo deterministico.La nostra programmazione
Le sfide ti aiuteranno a sapere perché gli algoritmi randomizzati sono utili
E perché alcuni di loro hanno un vantaggio competitivo rispetto al deterministico
Algoritmi.

---
layout: 
title: Pagina 40
level: 3
---


2.7.Algoritmi randomizzati
21
7
2
5
3
7 13 1
6
7
2
5
3
7 13 1
6
7
2
5
3
7 13
1
6
7
2
5
3
7
13
1
6
2
7
3
5
7 13
1
6
2
3
5
7
1
6
7 13
1
2
3
5
6
7
7 13
Figura 2.3:
L'albero di ricorsione per aver ordinato un array a 8 elementi con
Mergesort.I passaggi di divisione (superiore) sono costituiti da log2 8 = 3 livelli, dove
L'array di input è diviso in subarray sempre più piccoli.Il conquista
I passaggi (più bassi) sono costituiti dallo stesso numero di livelli, come i subarrays ordinati
vengono unito insieme.

---
layout: 
title: Pagina 41
level: 3
---


22
Capitolo 2. Tecniche di progettazione dell'algoritmo
Per dare un esempio di un algoritmo randomizzato, discuteremo prima
Una tecnica di smistamento rapido chiamato QuickSort.Seleziona un elemento m (tip-
icly, il primo) da un array C e semplicemente divide l'array in due
Subarrays: CSMall, contenente tutti gli elementi di C che sono più piccoli di M;
e Clarge contenente tutti gli elementi più grandi di m.
Questo partizionamento può essere eseguito in tempo lineare e seguendo una divisione-
e conquista della strategia, QuickSort ordina in modo ricorsivo ogni subarray nel
stessa strada.L'elenco ordinato viene facilmente creato semplicemente concatenando il
CSMall ordinato, elemento M e Clarge ordinato.
Quicksort (c):
Se C è costituito da un singolo elemento:
restituzione c
M ← C [1]
Determina l'insieme di elementi csMall più piccolo di m
Determina l'insieme di elementi Clarge più grande di m
QuickSort (CSMall)
QuickSort (Clarge)
Combina CSMall, M e Clarge in un singolo array ordinato Csorted
restituire csorted
Si scopre che il tempo di esecuzione di QuickSort dipende da quanto fortunato
Siamo con la nostra selezione dell'elemento m.Se ci capita di scegliere M in
In questo modo che l'array c sia diviso in metà uniforme (cioè | csmall | = | clarge |),
Poi
T (n) = 2t
n
2

+ a · n,
dove t (n) rappresenta il tempo impiegato da QuickSort per ordinare una serie di
n numeri e a · n rappresenta il tempo necessario per dividere l'array di dimensioni n
in due parti;A è una costante positiva.Questa è esattamente la stessa ricorrenza
Come in Mergesort che porta al tempo di esecuzione di O (NLOGN).
Tuttavia, se scegliamo m in modo tale da dividersi in modo non uniforme (ad esempio,
Un caso estremo si verifica quando CSMall è vuoto e Clarge ha n -1 elementi),
allora la ricorrenza sembra
T (n) = t (n −1) + a · n.
Questa è la ricorrenza che porta al tempo di esecuzione di O (N2), qualcosa che noi
voglio evitare.In effetti, QuickSort impiega il tempo quadratico per ordinare l'array

---
layout: 
title: Pagina 42
level: 3
---


2.7.Algoritmi randomizzati
23
(n, n −1, ..., 2,1).Peggio ancora, richiede tempo O (N2) per elaborare (1,2, ..., n -
1, n), che sembra inutile poiché l'array è già ordinato.
L'algoritmo QuickSort finora sembra una cattiva imitazione di
Mergesort.Tuttavia, se possiamo scegliere un buon "splitter" M che si rompe
Un array in due parti uguali, potremmo migliorare il tempo di esecuzione.A
raggiungere il tempo di esecuzione di O (NLOGN), in realtà non è necessario trovare un
Dividi (50/50) fectualmente.Ad esempio, una divisione approssimativamente uguale
Anche parti di dimensioni, 51/49 funzionano.In effetti, si può dimostrare che il
Il goritmo raggiungerà il tempo di esecuzione di O (NLOGN) fintanto che i set CSMall e
Clarge sono entrambi di dimensioni più grandi di N/4.
Implica che, di n possibili scelte per m come elementi dell'array c,
almeno 3n
4 −n
4 = n
2 di loro fanno buoni splitter!In altre parole, se corressimo
Domly Scegli m (cioè ogni elemento dell'array C ha la stessa probabilità
Per essere scelto), c'è almeno il 50% di probabilità che sia un buon splitter.
Questa osservazione motiva il seguente algoritmo randomizzato:
Randomizzatoquicksort (c):
Se C è costituito da un singolo elemento:
restituzione c
Seleziona casualmente un elemento M da C
Determina l'insieme di elementi csMall più piccolo di m
Determina l'insieme di elementi Clarge più grande di m
Randomizzatoquicksort (CSMall)
Randomizzatoquicksort (Clarge)
Combina CSMall, M e Clarge in un singolo array ordinato Csorted
restituire csorted
Randomizzatoquicksort è un algoritmo veloce in pratica, ma è peggiore
Il tempo di esecuzione del caso rimane O (N2) poiché esiste ancora la possibilità che sia
Seleziona Bad Splitter.Sebbene il comportamento di un algoritmo randomizzato
varia sullo stesso input da un'esecuzione all'altro, si può dimostrare
Che il tempo di esecuzione previsto è O (NLOGN).Il tempo di esecuzione di una corsa
L'algoritmo dominato è una variabile casuale e gli informatici sono spesso
interessato al valore medio di questa variabile casuale a cui si fa riferimento
come il tempo di esecuzione previsto.
Il vantaggio chiave degli algoritmi randomizzati è la performance:
per
Molti problemi pratici algoritmi randomizzati sono più veloci (nel senso
di tempo di esecuzione previsto) rispetto agli algoritmi deterministici più noti.

---
layout: 
title: Pagina 43
level: 3
---


24
Capitolo 2. Tecniche di progettazione dell'algoritmo
Un'altra caratteristica attraente di algoritmi randomizzati, come illustrato da
Randomizzatoquicksort, è la loro semplicità.
Sottolineiamo che randomizzatoquicksort, nonostante abbia fatto casuale
decisioni, restituisce sempre la soluzione corretta del problema di smistamento.IL
Solo la variabile da una corsa all'altra è il suo tempo di esecuzione, non il risultato.In
Contrasto, altri algoritmi randomizzati di solito producono errato (o, altro
Soluzioni delicatamente, approssimative).Algoritmi randomizzati che ritornano sempre
Le risposte corrette sono chiamate algoritmi di Las Vegas, mentre gli algoritmi che lo fanno
Non sono chiamati algoritmi Monte Carlo.Naturalmente, gli informatici pre-
Fer Las Vegas Algoritmi agli algoritmi Monte Carlo, ma i primi lo sono
Spesso di € da venire.

---
layout: 
title: Pagina 44
level: 3
---


Capitolo 3: Sfide di programmazione
Per presentarti al nostro sistema di classificazione automatizzato, ne discuteremo due
semplici sfide di programmazione e guidarti attraverso un pro-passo passo-passo
cedere di risolverli.Incontreremo diverse insidie ​​comuni e lo facciamo
Mostrarti come risolverli.
Di seguito è riportata una breve panoramica di ciò che serve per risolvere un Chal- di programmazione
Lenge in cinque passi:
Dichiarazione del problema di lettura.L'istruzione del problema specifica l'input
Formato di output, i vincoli per i dati di input e il tempo e
Limiti di memoria.Il tuo obiettivo è implementare un programma veloce che risolve
Il problema e funziona entro i limiti di tempo e memoria.
Progettazione di un algoritmo.Quando l'istruzione del problema è chiara, inizia a de-
Firmare un algoritmo e non dimenticare di dimostrare che funziona correttamente.
Implementazione di un algoritmo.Dopo aver sviluppato un algoritmo, inizia
implementarlo in un linguaggio di programmazione a tua scelta.
Test e debug del programma.Il test è l'arte di rivelare
bug.Il debug è l'arte di sterminare i bug.Quando il tuo
Il programma è pronto, inizia a testarlo!Se viene trovato un bug, lo fai e prova
Ancora.
Inviare il tuo programma al sistema di classificazione.Dopo il test e la de-
Inghinging del tuo programma, invialo al sistema di classificazione e attendi
Il messaggio "Buon lavoro!".Nel caso in cui si vede un messaggio diverso,
Torna alla fase precedente.
25

---
layout: 
title: Pagina 45
level: 3
---


26
Capitolo 3. Sfide di programmazione
3.1
Somma di due cifre
Somma di due cifre problema
Calcola la somma di due numeri a singola cifra.
Input: due numeri a singola cifra.
Output: la somma di questi num-
bers.
2 + 3 = 5
Iniziamo da questo problema ridicolmente semplice per mostrarti il
Pipeline della lettura dell'affermazione del problema, progettazione di un algoritmo, im-
implementarlo, testare e debug del tuo programma e inviarlo a
il sistema di classificazione.
Formato di input.Numeri interi A e B sulla stessa linea (separati da uno spazio).
Formato di output.La somma di a e b.
Vincoli.0 ≤a, b ≤9.
Campione.
Ingresso:
9 7
Produzione:
16
Limiti di tempo (sec.):
C C ++ Java Python
C#
Haskell Javascript Ruby Rust Scala
1
1
1.5
5
1.5
2
5
5
1
3
Limite di memoria.512 MB.

---
layout: 
title: Pagina 46
level: 3
---


3.1.Somma di due cifre
27
Per questo banale problema, salteremo il passaggio di "progettazione di un algoritmo"
e si sposterà direttamente sullo pseudocodice.
Sumoftwodigits (a, b):
restituire a + b
Poiché lo pseudocodico non specifica come inseriamo A e B, di seguito noi
fornire soluzioni in linguaggi di programmazione C ++, Java e Python3 come
così come consigli sulla compilazione e la gestione.Puoi copiare-
e incollare il codice per un file, compilare/eseguirlo, testarlo su alcuni set di dati e
quindi inviare (il file di origine, non l'eseguibile compilato) alla classificazione
sistema.Inutile dire che supponiamo che tu conosca le basi di uno di
Lingue di programmazione che utilizziamo nel nostro sistema di classificazione.
C ++
#includere
int main () {
int a = 0;
int b = 0;
std :: cin >> a;
std :: cin >> b;
std :: cout << a + b;
restituzione 0;
}
Salva questo su un file (diciamo, aplusb.cpp), compilalo, esegui il risultato
eseguibile e immettere due numeri (sulla stessa riga).
Giava
import java.util.scanner;
class aPlusb {
public static void main (string [] args) {
Scanner S = new Scanner (System.in);
int a = s.nextint ();
int b = s.nextInt ();
System.out.println (a + b);
}
}

---
layout: 
title: Pagina 47
level: 3
---


28
Capitolo 3. Sfide di programmazione
Salva questo su un file aplusb.java, compilalo, esegui l'exe- risultante
Calcobile e inserisci due numeri (sulla stessa riga).
Python3
# Usa python3
Import sys
input = sys.stdin.read ()
token = input.split ()
A = int (token [0])
B = int (token [1])
Stampa (A + B)
Salva questo su un file (diciamo, aplusb.py), eseguilo e inserisci due numeri
sulla stessa linea.Per indicare la fine dell'ingresso, premere Ctrl-D/Ctrl-
z.(La prima riga nel codice sopra indica al sistema di classificazione di utilizzare
Pithon3 piuttosto pithon2.)
Il tuo obiettivo è implementare un algoritmo che produca un risultato corretto
In base ai limiti di tempo e memoria per qualsiasi input che soddisfa il dato
vincoli.Non è necessario verificare che i dati di input soddisfi il
vincoli, ad esempio, per la somma del problema di due cifre non è necessario
Controlla che i numeri interi dati A e B siano effettivamente numeri interi a una cifra (questo
è garantito).

---
layout: 
title: Pagina 48
level: 3
---


3.2.Prodotto massimo a coppie
29
3.2
Prodotto massimo a coppie
Problema del prodotto massimo a coppie
Trova il prodotto massimo di due numerosi distinti
bers in una sequenza di numeri interi non negativi.
Input: una sequenza di non negativi
numeri interi.
Output: il valore massimo che
può essere ottenuto moltiplicando
due diversi elementi dal se-
Queence.
5
6
2
7
4
5
30 10 35 20
6 30
12 42 24
2 10 12
7
4
7 35 42 14
28
4 20 24 8 28
Data una sequenza di numeri interi non negativi a1, ..., an, calcola
max
1≤i, j≤nai · aj.
Nota che io e J dovrebbero essere diversi, sebbene possa essere il caso che ai = AJ.
Formato di input.La prima linea contiene un numero intero n.La riga successiva contiene
n numeri interi non negativi A1, ..., un (separato da spazi).
Formato di output.Il prodotto massimo a coppie.
Vincoli.2 ≤n ≤2 · 105;0 ≤a1, ..., un ≤2 · 105.
Campione 1.
Ingresso:
3
1 2 3
Produzione:
6

---
layout: 
title: Pagina 49
level: 3
---


30
Capitolo 3. Sfide di programmazione
Campione 2.
Ingresso:
10
7 5 14 2 8 8 10 1 2 3
Produzione:
140
Limiti di tempo e memoria.Lo stesso del problema precedente.
3.2.1
Algoritmo ingenuo
Un modo ingenuo per risolvere il massimo problema del prodotto è andare
attraverso tutte le possibili coppie degli elementi di input A [1 ... n] = [A1, ..., an] e
per trovare una coppia di elementi distinti con il prodotto più grande:
Maxpairwiseproductnaive (a [1 ... n]):
Prodotto ← 0
per io da 1 a n:
per j da 1 a n:
Se io, j:
If Product <a [i] · a [j]:
Prodotto ← A [i] · A [J]
Return Product
Questo codice può essere ottimizzato e reso più compatto come segue.
Maxpairwiseproductnaive (a [1 ... n]):
Prodotto ← 0
per io da 1 a n:
per j da i + 1 a n:
Prodotto ← Max (prodotto, a [i] · a [j])
Return Product
Implementa questo algoritmo nel tuo linguaggio di programmazione preferito.Se
Stai usando C ++, Java o Python3, potresti voler scaricare l'antipasto
file (forniamo soluzioni di avviamento in queste tre lingue per tutti i problemi
Lems nel libro).Per altre lingue, devi implementare il tuo solu-
zione da zero.

---
layout: 
title: Pagina 50
level: 3
---


3.2.Prodotto massimo a coppie
31
Le soluzioni di avviamento per C ++, Java e Python3 sono mostrate di seguito.
C ++
#includere
#includere
usando std :: vector;
usando std :: cin;
usando std :: cout;
usando std :: max;
int maxpairwiseProduct (const vector & numeri) {
int prodotto = 0;
int n = numeras.size ();
per (int i = 0; i <n; ++ i) {
per (int j = i +1; j <n; ++ j) {
Product = Max (Product, Numbers [i] \* Numeri [j]);
}
}
restituire il prodotto;
}
int main () {
int n;
CIN >> n;
Numeri vettoriali (N);
per (int i = 0; i <n; ++ i) {
CIN >> numeri [i];
}
INT Product = MaxPairWiseProduct (numeri);
cout << prodotto << "\ n";
restituzione 0;
}
Giava
import java.util. \*;
import java.io. \*;

---
layout: 
title: Pagina 51
level: 3
---


32
Capitolo 3. Sfide di programmazione
Classe pubblica MaxPairwiseProduct {
static int getMaxPairWiseProduct (int [] numeri) {
int prodotto = 0;
int n = numeras.length;
per (int i = 0; i <n; ++ i) {
per (int j = i +1; j <n; ++ j) {
Product = Math.max (Product,
numeri [i] \* numeri [j]);
}
}
restituire il prodotto;
}
public static void main (string [] args) {
FastScanner Scanner = new FastScanner (System.in);
int n = scanner.nexTint ();
int [] numeri = new int [n];
per (int i = 0; i <n; i ++) {
numeri [i] = scanner.nexTint ();
}
System.out.println (getMaxPairWiseProduct (Numer));
}
classe statica FastScanner {
BufferedReader BR;
StringTokenizer St;
FastScanner (inputStream Stream) {
Tentativo {
br = nuovo bufferedReader (nuovo
InputStreamReader (Stream));
} catch (eccezione e) {
e.printStackTrace ();
}
}
String next () {
while (st == null ||! St.HasmoreTokens ()) {
Tentativo {

---
layout: 
title: Pagina 52
level: 3
---


3.2.Prodotto massimo a coppie
33
st = new StringTokenizer (Br.Readline ());
} catch (ioException e) {
e.printStackTrace ();
}
}
restituire St.NextToken ();
}
int nextInt () {
return integer.parseint (next ());
}
}
}
Pitone
# Usa python3
n = int (input ())
a = [int (x) per x in input (). split ()]
Prodotto = 0
per i in gamma (n):
per j in gamma (i + 1, n):
Product = Max (Product, A [i] \* A [J])
Stampa (prodotto)
Dopo aver inviato questa soluzione al sistema di classificazione, molti studenti
sono sorpresi quando vedono il seguente messaggio:
Caso non riuscito n. 4/17: limite di tempo superato
Dopo aver inviato il tuo programma, lo testiamo su dozzine di de-
Casi di test firmati per assicurarsi che il programma sia rapido e a prova di errore.Come il
Risultato, di solito sappiamo che tipo di errori hai commesso.Il messaggio sopra
dice che il programma inviato supera il limite di tempo al 4 °
17 casi di test.
Fermati e pensa.Perché la soluzione non si adatta al limite di tempo?

---
layout: 
title: Pagina 53
level: 3
---


34
Capitolo 3. Sfide di programmazione
Maxpairwiseproductnaive si esibisce dell'ordine di N2 passi su un se-
QUECCIA DI LONGA N.
Per il valore massimo possibile n = 2 · 105, il
Il numero di passaggi è dell'ordine 4 · 1010.
Dal momento che molti moderni
I puters eseguono circa 108-109 operazioni di base al secondo (questo de-
pende su una macchina, ovviamente), potrebbero essere necessari decine di secondi
Maxpairwiseproductnaive, superando il limite di tempo per il massimo
Problema del prodotto a coppie.
Abbiamo bisogno di un algoritmo più veloce!
3.2.2
Algoritmo veloce
Alla ricerca di un algoritmo più veloce, giochi con piccoli esempi come
[5,6,2,7,4].Eureka: è sufficiente per moltiplicare i due maggiori elementi di
L'array: 7 e 6!
Dal momento che dobbiamo trovare il più grande e il secondo elemento più grande, noi
necessitano solo di due scansioni della sequenza.Durante la prima scansione, abbiamo trovato il
elemento più grande.
Durante la seconda scansione, abbiamo trovato l'elemento più grande
tra i restanti saltando l'elemento che si trova alla previsione
ous scan.
Maxpairwiseproductfast (a [1 ... n]):
INDICE1 ← 1
per io da 2 a n:
Se a [i]> a [indice1]:
INDICE1 ← i
INDICE2 ← 1
per io da 2 a n:
Se a [i], a [index1] e a [i]> a [index2]:
INDICE2 ← i
restituire a [index1] · a [index2]
3.2.3
Test e debug
Implementare questo algoritmo e testarlo usando un input a = [1,2].Lo farà
Output 2, come previsto.Quindi, controlla l'input A = [2,1].Sorprendentemente, questo
Output 4. Ispezionando il codice, lo si trova dopo il primo ciclo,
indice1 = 1. L'algoritmo inizializza quindi indice2 a 1 e index2 non è mai

---
layout: 
title: Pagina 54
level: 3
---


3.2.Prodotto massimo a coppie
35
Aggiornato dal secondo per loop.Di conseguenza, indice1 = indice2 prima del
Dichiarazione di ritorno.Per garantire che ciò non accada, si modifica il
pseudocodice come segue:
Maxpairwiseproductfast (a [1 ... n]):
INDICE1 ← 1
per io da 2 a n:
Se a [i]> a [indice1]:
INDICE1 ← i
if indice1 = 1:
INDICE2 ← 2
altro:
INDICE2 ← 1
per io da 1 a n:
Se a [i], a [index1] e a [i]> a [index2]:
INDICE2 ← i
restituire a [index1] · a [index2]
Controlla questo codice su piccoli set di dati [7,4,5,6] per garantire che produca
Risultati corretti.Quindi prova un input
2
100000 90000
Puoi scoprire che il programma produce qualcosa come 410065408 o
anche un numero negativo anziché il risultato corretto 9000000000. Se lo è
Fa, questo è probabilmente causato da un flusso eccessivo intero.Ad esempio, in
Linguaggio di programmazione C ++ Un numero elevato come 9000000000 non si adatta
Nel tipo int standard che sulla maggior parte delle macchine moderne occupa 4 byte
e varia da -231 a 231 −1, dove
231 = 2147483648.
Quindi, invece di usare il tipo C ++ int è necessario utilizzare il tipo di int64 t
Quando si calcola il prodotto e si memorizza il risultato.Questo impedirà
Il flusso di interi in quanto il tipo int64 t occupa 8 byte e vaccano da
Da −263 a 263 −1, dove
263 = 9223372036854775808.

---
layout: 
title: Pagina 55
level: 3
---


36
Capitolo 3. Sfide di programmazione
Quindi procedi al test del programma su set di dati di grandi dimensioni, ad esempio un
Array A [1 ... 2 · 105], dove a [i] = i per tutti 1 ≤i ≤2 · 105.Ci sono due modi
di farlo.
1. Crea
Questo
vettore
In
tuo
programma
E
passaggio
Esso
A
Maxpairwiseproductfast (invece di leggerlo dallo stan-
Input DARD).
2. Crea un programma separato, che scrive un tale array su un file
Dataset.txt.Quindi passa questo set di dati al tuo programma dalla console
come segue:
YourProgram <DataSet.txt
Verificare che il tuo programma elasse questo set di dati entro il limite di tempo e ri-
gira il risultato corretto: 39999800000. Ora si è convinti che il
Il programma funziona finalmente!
Tuttavia, dopo averlo inviato al sistema di test, fallisce di nuovo ...
Caso #5/17 non riuscito: Risposta sbagliata
Ma come genereresti un caso di test che rende il tuo programma fallire e
Aiutarti a capire cosa è andato storto?
3.2.4
Puoi dirmi quale errore ho fatto?
Probabilmente ti stai chiedendo perché non ti abbiamo fornito il 5 ° fuori
di 17 set di dati di test che hanno abbattuto il programma.Il motivo è quello
Nessuno ti fornirà i casi di test nella vita reale!
Poiché anche i programmatori esperti commettono spesso errori sottili
Ing problemi algoritmici, è importante imparare a catturare i bug come
presto possibile.Quando gli autori di questo libro hanno iniziato a programmare, loro
Ho pensato ingenuamente che quasi tutti i loro programmi fossero corretti.Ormai noi
Sappi che i nostri programmi non sono quasi mai corretti quando li gestiamo.
Quando si propone che il tuo programma funziona, spesso lo provi
solo alcuni casi di test e se le risposte sembrano ragionevoli, consideri il tuo
lavoro fatto.Tuttavia, questa è una ricetta per un disastro.Per creare il tuo programma
Lavora sempre, dovresti testarlo su una serie di casi di test attentamente progettati.
Imparare a implementare algoritmi, nonché testare e eseguire il debug
I programmi saranno preziosi nel tuo lavoro futuro come programmatore.

---
layout: 
title: Pagina 56
level: 3
---


3.2.Prodotto massimo a coppie
37
3.2.5
Test di stress
Ora introdurremo test di stress: una tecnica per generare
sabbie di test con l'obiettivo di trovare un caso di test per il quale la soluzione
non riesce.
Uno stress test è composto da quattro parti:
1. La tua implementazione di un algoritmo.
2. un'implementazione alternativa, banale e lenta, ma corretta di un
Algoritmo per lo stesso problema.
3. Un generatore di test casuali.
4. Un ciclo in ﬁ nita in cui viene generato un nuovo test e immesso in entrambi
Implementazioni per confrontare i risultati.Se i loro risultati differiscono, il
test ed entrambe le risposte sono output e il programma si interrompe, altrimenti
il loop si ripete.
L'idea alla base dello stress test è che due implementazioni corrette
dovrebbe dare la stessa risposta per ogni test (a condizione che la risposta al
Il problema è unico).Se, tuttavia, una delle implementazioni non è corretta,
Quindi esiste un test su cui le loro risposte differiscono.L'unico caso quando
Non è così quando c'è lo stesso errore in entrambe le implementazioni,
Ma è improbabile (a meno che l'errore non sia da qualche parte nell'input/output
routine comuni ad entrambe le soluzioni).In effetti, se una soluzione lo è
corretto e l'altro è sbagliato, quindi esiste un caso di test su cui loro
Di ﬀ er.Se entrambi sono sbagliati, ma i bug sono diversi, allora molto probabilmente lì
esiste un test su cui due soluzioni danno risultati diversi.
Ecco lo stress test per MaxPairWiseProductfast usando
Maxpairwiseproductnaive come banale implementazione:

---
layout: 
title: Pagina 57
level: 3
---


38
Capitolo 3. Sfide di programmazione
Stresstest (n, m):
mentre è vero:
N ← Intero casuale tra 2 e n
Allocate Array A [1 ... N]
per io da 1 a n:
A [i] ← Intero casuale tra 0 e m
stampa (a [1 ... n])
Risultato1 ← MaxPairWiseProductNaive (a)
Risultato2 ← MaxPairWiseProductFast (A)
se risultato1 = risultato2:
Stampa ("OK")
altro:
Stampa ("Risposta sbagliata:", risultato1, risultato2)
ritorno
Il ciclo while sopra inizia con la generazione della lunghezza dell'input
sequenza n, un numero casuale tra 2 e N. è almeno 2, perché
L'istruzione del problema specifica che n ≥2.Il parametro n dovrebbe essere
abbastanza piccolo da permetterci di esplorare molti test nonostante il fatto che uno di
Le nostre soluzioni sono lente.
Dopo aver generato N, generiamo un array A con n numeri casuali
da 0 a m e produrre in modo che nel processo del ciclo infinito
Sappi sempre qual è il test attuale;Questo renderà più facile catturare un
Errore nel codice di generazione di test.Chiamiamo quindi due algoritmi su un e
Confronta i risultati.Se i risultati sono diversi, li stampiamo e ci fermiamo.
Altrimenti, continuiamo il ciclo while.
Corriamo StressTest (10.100000) e manteniamo le nostre refere
Una speranza che produca "risposta sbagliata".Vediamo qualcosa di simile (il
Il risultato può essere diverso sul tuo computer a causa di un diverso casuale
generatore di numeri).
...
OK
67232 68874 69499
OK
6132 56210 45236 95361 68380 16906 80495 95298
OK
62180 1856 89047 14251 8362 34171 93584 87362 83341 8784
OK

---
layout: 
title: Pagina 58
level: 3
---


3.2.Prodotto massimo a coppie
39
21468 16859 82178 70496 82939 44491
OK
68165 87637 74297 2904 32873 86010 87637 66131 82858 82935
Risposta sbagliata: 7680243769 7537658370
Evviva!Abbiamo trovato un caso di test in cui MaxPairWiseProductnaive
e MaxPairWiseProductFast producono risultati diversi, quindi ora possiamo
Controlla cosa è andato storto.Quindi possiamo eseguire il debug di questa soluzione in questo test
Caso, trovare un bug, risolverlo e ripetere di nuovo lo stress test.
Fermati e pensa.Vedi qualcosa di sospetto nel set di dati trovato?
Si noti che la generazione di test automaticamente e l'esecuzione dello stress test è facile,
Ma il debug è difficile.Prima di immergerti nel debug, proviamo a generare
un caso di test più piccolo per semplificarlo.Per fare ciò, cambiamo n da 10 a 5
e M da 100000 a 9.
Fermati e pensa.Perché abbiamo praticato la prima cosa stressante con un grande parame
TERS N e M e ora intendono eseguirlo con N e M?
Quindi eseguiamo di nuovo lo stress test e produce quanto segue.
...
7 3 6
OK
2 9 3 1 9
Risposta sbagliata: 81 27
Il lento maxpairwiseProductnaive fornisce la risposta corretta 81 (9 · 9 =
81), ma il rapido MaxPairWiseProductfast fornisce una risposta errata 27.
Fermati e pensa.In che modo MaxPairwiseProductFast può eventualmente restituire 27?
Per eseguire il debug della nostra soluzione veloce, controlliamo quali due numeri identifica
come due più grandi.Per questo, aggiungiamo la seguente riga prima del ritorno
Dichiarazione della funzione MaxPairWiseProductFast:
Stampa (INDICE1, INDICE2)
Dopo aver eseguito di nuovo lo stress test, vediamo quanto segue.
...
7 3 6
1 3

---
layout: 
title: Pagina 59
level: 3
---


40
Capitolo 3. Sfide di programmazione
OK
5
2 9 3 1 9
2 3
Risposta sbagliata: 81 27
Si noti che le nostre soluzioni hanno funzionato e poi non sono riuscite esattamente
Test dei casi come nella precedente serie dello stress test, perché non l'abbiamo fatto
Cambia qualsiasi cosa nel generatore di test.I numeri che utilizza per generare
I test sono pseudorandom piuttosto che casuali, significa che la sequenza
Sembra casuale, ma è lo stesso ogni volta che eseguiamo questo programma.È
una proprietà conveniente e importante e dovresti provare ad avere il tuo
i programmi mostrano tale comportamento, perché programmi deterministici (che al-
i modi danno lo stesso risultato per lo stesso input) sono più facili da eseguire il debug
quelli non deterministici.
Ora esaminiamo indice1 = 2 e index2 = 3. Se guardiamo il codice per
Determinazione del secondo massimo, noteremo un bug sottile.Quando noi
implementato una condizione su i (in modo tale che non sia uguale alla previsione
ous massimo) invece di confrontare i e indice1, abbiamo confrontato un [i] con
A [indice1].Ciò garantisce che il secondo massimo
massimo dal valore piuttosto che dall'indice dell'elemento che noi
Selezionare per risolvere il problema del prodotto massimo a coppie.Quindi, il nostro solu-
zione fallisce in qualsiasi caso di test in cui il numero più grande è uguale al secondo
numero maggiore.Ora cambiamo la condizione da
A [i], a [indice1]
A
I, indice1
Dopo aver eseguito di nuovo lo stress test, vediamo una raffica di messaggi "OK"
sullo schermo.Aspettiamo un minuto fino a quando non ci annoiamo e poi decidiamo
Quel MaxPairWiseProductFast è finalmente corretto!
Tuttavia, non dovresti fermarti qui, dal momento che hai generato solo molto
piccoli test con n = 5 e m = 10. dovremmo verificare se il nostro pro-
Gram funziona per N più grandi elementi più grandi dell'array.Quindi, cambiamo
Da N a 1000 (per N più grande, la soluzione ingenua sarà piuttosto lenta, perché
Il suo tempo di esecuzione è quadratico).Cambiamo anche M a 200000 e gestiamo.Noi
Vedi di nuovo lo schermo che riempie con le parole "ok", aspetta un minuto e poi

---
layout: 
title: Pagina 60
level: 3
---


3.2.Prodotto massimo a coppie
41
Decidi che (finalmente!) MaxPairWiseProductFast è corretto.Successivamente, noi
inviare la soluzione risultante al sistema di classificazione e passare il massimo
Test del problema del prodotto a coppie di mamma!
Come vedi, anche per problemi così semplici come il massimo a coppie
Prodotto, è facile commettere errori sottili durante la progettazione e l'implerazione
mentando un algoritmo.Lo pseudocode di seguito presenta un più "affidabile"
modo di implementare l'algoritmo.
Maxpairwiseproductfast (a [1 ... n]):
indice ← 1
per io da 2 a n:
Se a [i]> a [indice]:
indice ← i
scambia un [indice] e un [n]
indice ← 1
Per I da 2 a n −1:
Se a [i]> a [indice]:
indice ← i
scambia un [indice] e un [n −1]
restituire a [n −1] · a [n]
In questo libro, oltre a imparare a progettare e analizzare gli algoritmi,
Imparerai come implementare algoritmi in un modo che minimizza il
Probabilità di commettere un errore e come testare le tue implementazioni.
3.2.6
Algoritmo ancora più veloce
L'algoritmo MaxPairwiseProductFast trova il più grande e il secondo
I maggiori elementi in circa 2n confronti.
Pausa di esercizio.Trova due elementi più grandi in un array in 1,5N di confronto
ISON.
Dopo aver risolto questo problema, prova il prossimo, ancora più impegnativo
pausa cise.
Pausa di esercizio.Trova due elementi più grandi in un array in N + ⌈log2 N⌉ - 2
confronti.

---
layout: 
title: Pagina 61
level: 3
---


42
Capitolo 3. Sfide di programmazione
E se ritieni che la precedente pausa di esercizio fosse facile, ecco il
Le prossime due sfide che potresti affrontare alla tua prossima intervista!
Pausa di esercizio.Dimostrare che nessun algoritmo per trovare due maggiori elementi
In un array può farlo in confronti inferiori a n + ⌈log2 n⌉ - 2.
Pausa di esercizio.Qual è l'algoritmo più veloce per trovare tre più grandi
elementi?
3.2.7
Un algoritmo più compatto
Il problema massimo del prodotto a coppie può essere risolto da quanto segue
Algoritmo compatto che utilizza l'ordinamento (in ordine non decrescente).
MaxpairwiseProductBysorting (a [1 ... n]):
Ordin (a)
restituire a [n −1] · a [n]
Questo algoritmo fa più di quanto abbiamo effettivamente bisogno: invece di trovare due
I maggiori elementi, ordina l'intero array.Per questo motivo, è il tempo di esecuzione
è O (nlogn), ma non O (n).Tuttavia, per i vincoli forniti (2 ≤n ≤2 · 105)
Questo di solito è sufficientemente veloce per riempire in un secondo e passare il nostro selezionatore.
3.3
Risolvere una sfida di programmazione in cinque
Passi facili
Di seguito riassumiamo ciò che abbiamo imparato in questo capitolo.
3.3.1
Dichiarazione del problema di lettura
Inizia leggendo l'affermazione del problema che contiene la descrizione di
Un compito computazionale, limiti di tempo e memoria e alcuni test di esempio.
Assicurati di capire come un output corrisponde a un input in ogni sam-
PLE CASE.
Se i limiti di tempo e memoria non sono specifici esplicitamente nel problema
Dichiarazione, vengono utilizzati i seguenti valori predefiniti.

---
layout: 
title: Pagina 62
level: 3
---


3.3.Risolvere una sfida di programmazione in cinque semplici passaggi
43
Limiti di tempo (sec.):
C C ++ Java Python
C#
Haskell Javascript Ruby Rust Scala
1
1
1.5
5
1.5
2
5
5
1
3
Limite di memoria: 512 MB.
3.3.2
Progettazione di un algoritmo
Dopo aver progettato un algoritmo, dimostra che è corretto e prova a stimare
è previsto il tempo di esecuzione sugli input più complessi specificati nel
Sezione vincoli.Se il tuo laptop esegue circa 108-109 operazioni
al secondo e la dimensione massima di un set di dati nella descrizione del problema
è n = 105, quindi è improbabile che un algoritmo con tempo di esecuzione quadratico
adattare al limite di tempo (poiché N2 = 1010), mentre una soluzione con tempo di esecuzione
O (NLOGN) Will.Tuttavia, una soluzione O (N2) si adatta se n = 1000 e se
N = 100, anche una soluzioni O (N3) si adatteranno.Sebbene algoritmi polinomiali
rimanere sconosciuto per alcuni problemi difficili in questo libro, una soluzione con
O (2nn2) il tempo di esecuzione probabilmente si adatta al limite di tempo finché n è
più piccolo di 20.
3.3.3
Implementazione di un algoritmo
Inizia a implementare il tuo algoritmo in uno dei seguenti programmi
Lingue Ming supportate dal nostro sistema di classificazione automatizzato: C, C ++, C#,
Haskell, Java, Javascript, Python2, Python3, Ruby o Scala.Per tutti
Problemi, forniamo soluzioni di avviamento per C ++, Java e Python3.Per
Altri linguaggi di programmazione, è necessario implementare una soluzione da
graffio.Il sistema di classificazione rileva il linguaggio di programmazione del tuo
Invio automaticamente, in base all'estensione del file di invio.
Abbiamo soluzioni di riferimento in C ++, Java e Python3 (che non lo facciamo
condividere con te) che risolvono correttamente il problema sotto il
ceppo e spendi al massimo 1/3 del limite di tempo e al massimo 1/2 del
Limite di memoria.Puoi anche usare altre lingue e abbiamo stimato il
Moltiplicatori di tempo per loro.Tuttavia, non abbiamo alcuna garanzia che un Cor-
RECT SOLUZIONE per un problema particolare in esecuzione sotto il tempo e
I vincoli di memoria esistono in una di quelle altre lingue.

---
layout: 
title: Pagina 63
level: 3
---


44
Capitolo 3. Sfide di programmazione
Nell'appendice, elenchiamo versioni e bandiere del compilatore utilizzate dal grado
Sistema ing.Ti consigliamo di utilizzare le stesse porte al compilatore quando si verifica
la tua soluzione a livello locale.Ciò aumenterà le possibilità che il tuo programma sia
Have allo stesso modo sulla macchina e sulla macchina di prova (nota
che un programma buggy possa comportarsi in modo diverso se compilato da diverso
compilatori, o anche dallo stesso compilatore con diverse porte).
3.3.4
Test e debug
Inviare l'implementazione al sistema di classificazione senza testare
È prima una cattiva idea!Inizia con piccoli set di dati e assicurati che il tuo
Il programma produce risultati corretti su tutti i set di dati di esempio.Quindi procedere
Per controllare quanto tempo impiega per elaborare un set di dati di grandi dimensioni.Stimare il
tempo di esecuzione, ha senso implementare il tuo algoritmo come funzione
come risolvere (set di dati) e quindi implementare una procedura aggiuntiva
ATE () che produce un set di dati di grandi dimensioni.Ad esempio, se un input per un problema
è una sequenza di numeri interi di lunghezza 1 ≤n ≤105, quindi genera una sequenza di
Lunghezza 105, passalo alla funzione risolto () e assicurati che il programma
emette rapidamente il risultato.
Controlla i valori limite per garantire che il programma elabori
sequenze rettifiche sia brevi (ad esempio, con 2 elementi) e sequenze lunghe
(ad esempio, con 105 elementi).Se una sequenza di numeri interi da 0 a, diciamo, 106
viene dato come input, controlla come si comporta il tuo programma quando viene dato
Una sequenza 0,0, ..., 0 o una sequenza 106.106, ..., 106.Successivamente, controllalo
anche su dati generati casualmente.Controlla i casi degenerati come un vuoto
imposta, tre punti su una singola riga, un albero che consiste in un singolo percorso di
nodi, ecc.
Dopo che sembra che il tuo programma funzioni su tutti questi test, procedi
per lo stress test.Implementare un algoritmo lento, ma semplice e corretto e
Controlla che due programmi producano lo stesso risultato (nota tuttavia che questo
non è applicabile ai problemi in cui l'output non è unico).creare
Casi di test casuali e casi di test distorti come quelli con solo
piccoli numeri o una piccola gamma di grandi numeri, stringhe contenenti un peccato
Gle Letter "A" o solo due diverse lettere (al contrario delle stringhe composte
di tutte le possibili lettere latine) e così via.Pensa ad altri possibili test
che potrebbe essere peculiare in un certo senso.Ad esempio, se stai generando
grafici, prova a generare alberi, grafici disconnessi, grafici completi, bipar-
grafici tite, ecc. Se si generano alberi, prova a generare percorsi, alberi binari,

---
layout: 
title: Pagina 64
level: 3
---


3.4.Buone pratiche di programmazione
45
stelle, ecc. Se stai generando numeri interi, prova a generare sia Prime che
Numeri compositi.
3.3.5
Invio al sistema di classificazione
Quando hai finito con i test, invia il tuo programma al sistema di classificazione
TEM!Vai alla pagina di invio, crea una nuova invio e carica un file
con il tuo programma (assicurati di caricare un file di origine anziché un ex-
CALLABILE).Il sistema di classificazione quindi compila il programma e lo esegue
una serie di test attentamente costruiti per verificare che produca un risultato corretto
Per tutti i test e che si adatta ai limiti di tempo e di memoria.La classificazione
di solito richiede meno di un minuto, ma in rari casi, quando i server lo sono
sovraccarico, potrebbe richiedere più tempo.Per favore sii paziente.Puoi tranquillamente partire
La pagina quando viene caricata la soluzione.
Di conseguenza, ricevi un messaggio di feedback dal sistema di classificazione.Voi
voglio vedere il "buon lavoro!"messaggio che indica che il tuo programma è passato
Tutti i test.
I messaggi "Risposta sbagliata", "Limite di tempo superato",
"Limite di memoria superato" avvishi che il programma non è riuscito a causa di uno
di questi motivi.Se il programma fallisce su uno dei primi due casi di test, il
La elementare ti riferirà e ti mostrerà il caso di test e il fuori-
Metti del tuo programma.Questo viene fatto per aiutarti a ottenere l'input/output
formato giusto.In tutti gli altri casi, il selezionatore non ti mostrerà il caso di test
dove il tuo programma fallisce.
3.4
Buone pratiche di programmazione
La programmazione è un'arte per non commettere errori per uno.In questa sezione,
Descriveremo alcune buone pratiche per l'implementazione del software
ti aiuterà a evitare bug (obob) e molti altri comuni
insidie ​​di programmazione.Attenersi a queste buone pratiche ti aiuterà
Scrivi un codice affidabile, compatto, leggibile e debuggable.
Attenersi a uno stile di codice specifico.
La miscelazione di vari stili di codice nei tuoi programmi li rende meno letti-
capace.Vedi https://en.wikipedia.org/wiki/programming\_style to
Seleziona il tuo stile di codice preferito.

---
layout: 
title: Pagina 65
level: 3
---


46
Capitolo 3. Sfide di programmazione
Usa nomi significativi per le variabili.
L'uso di un nome simile alla velocità anziché a S aiuterà i membri del tuo team
Per leggere il tuo programma e ti aiuterà a eseguire il debug.
Accendi tutti gli avvisi di compilatore/interprete.
Anche se i programmatori inesperti a volte vedono gli avvisi come
un fastidio, ti aiutano a catturare alcuni bug nelle prime fasi di
Le tue implementazioni software.
Struttura il tuo codice.
Il paradigma di programmazione strutturato mira a migliorare la chiarezza
e riducendo il tempo di sviluppo dei tuoi programmi facendo ex-
Uso tensivo di subroutine.Rompi il tuo codice in molte subroutine
in modo tale che ogni subroutine sia responsabile di un'unica opera opera logica
zione.
Rendi il tuo codice compatto se non ne riduce la leggibilità.
Ad esempio, se la condizione è una variabile booleana, usa quest'ultima
I seguenti due programmi che raggiungono lo stesso obiettivo:
Se condizione:
restituire vero
altro:
restituire false
condizione di ritorno
Quando si calcola il numero minimo in un array, invece di
Se corrente <minimo:
minimo ← corrente
utilizzo
minimo ← min (minimo, corrente)

---
layout: 
title: Pagina 66
level: 3
---


3.4.Buone pratiche di programmazione
47
Usa le dichiarazioni Assert.
Ogni volta, c'è una condizione che deve essere vera in un certo punto di
Il tuo programma, aggiungi una riga
Assert (condizione)
Un postcondizionismo (presupposto) è un'affermazione che deve essere vera prima
(o dopo) la chiamata alla funzione.Ha senso dichiarare precondizioni
zioni e postcondizioni per ogni funzione del programma.Per
Esempio, ti risparmierebbe tempo se avessi aggiunto una riga
Assert (Index1, Index2)
Quando si implementa un algoritmo per il massimo a coppie.
Problema UCT nella Sezione 3.2.2.
Le dichiarazioni di assistenza possono anche essere utilizzate per garantire che un certo punto
Nel tuo programma non viene mai raggiunto.Vedere il seguente codice Python per
Calcolo del più grande divisore comune di due numeri interi positivi.
def gcd (a, b):
Affermare A> = 1 e B> = 1
per d nell'intervallo (min (a, b), 0, -1):
Se a % d == 0 e b % d == 0:
ritorno d
Affermare false
Evita il flusso di interi.
Controllare i limiti sui valori di input, stimare il valore massimo
Per i risultati intermedi e scegli un numerico sufficientemente grande
tipo.
Per C ++ in particolare, ha senso usare tipi di dimensioni esplicite come
int64 t invece di lungo, perché tipi come int, lunghi o lunghi
può avere dimensioni diverse a seconda della piattaforma di elaborazione.

---
layout: 
title: Pagina 67
level: 3
---


48
Capitolo 3. Sfide di programmazione
Quando si calcola il modulo M, prendi ogni Mod- di risultato intermedio
ULO M.Dì, devi calcolare il resto del prodotto di tutti
elementi di un array a [0..n −1] modulo 17. Il modo ingenuo di fare
Questo è il seguente.
Risultato ← 1
Per I da 0 a n −1:
Risultato ← Risultato · A [i]
Risultato Restituzione Mod 17
Nelle lingue con flusso eccessivo intero (come C ++ e Java) questo darà
un risultato sbagliato in molti casi: anche se n = 100 e un [i] = 2 per tutti i,
Il prodotto di una [i] non si adatta a 64 bit.In lingue con out-
aritmetica lunga da parte della scatola, questo codice sarà più lento del necessario (come
Il risultato sta diventando più grande ad ogni iterazione).Il modo giusto di solv-
questo compito è il seguente.
Risultato ← 1
Per I da 0 a n −1:
risultato ← (risultato · a [i]) mod 17
Risultato Restituzione Mod 17
Evita i numeri dei punti fluttuanti quando possibile.
Nel valore massimo del problema del bottino (Sezione 5.2) è necessario
per confrontare
pi
Wi
E
PJ
WJ
,
dove Pi e PJ (Wi e WJ) sono prezzi (pesi) di due composti.
Invece di confrontare questi numeri razionali, confronta i numeri interi pi · wj
e PJ · WI, poiché i numeri interi sono più veloci da calcolare e precisi.Tuttavia,
Ricorda che il flusso di interi finisce quando calcola i prodotti di grandi dimensioni
numeri!
Nei punti più vicini il problema (Sezione 6.6) è necessario confrontare
distanze tra una coppia di punti (x1, y1) e (x2, y2) e una coppia di
punti (x3, y3) e (x4, y4):
Q
(x1 −x2) 2 + (y1 −y2) 2 e
Q
(x3 −x4) 2 + (y3 −y4) 2.

---
layout: 
title: Pagina 68
level: 3
---


3.4.Buone pratiche di programmazione
49
Ancora una volta, invece di confrontare questi valori, confronta i valori di
i loro quadrati:
(x1 −x2) 2 + (y1 −y2) 2 e (x3 −x4) 2 + (y3 −y4) 2.
In effetti, in questo problema è necessario gestire i numeri non integratori
Solo una volta: quando si supera il risultato.
Usa array basato su 0.
Anche se l'istruzione del problema specifica una sequenza basata su 1 come
a1, ..., an, conservalo in un array basato su 0 a [0..n −1] (tale che a [i] = ai-1)
Invece di un array basato su 1 a [0..n] (tale che a [i] = ai).Nella maggior parte dei
Gli array di lingue Gramming sono basate su 0.Un array basato su 0 contiene
Solo i dati di input, mentre un array a [0..n] contiene un elemento fittizio
Ment A [0] che potresti utilizzare accidentalmente nel tuo programma.Per questo
Motivo, la dimensione di un array basato su 0 è uguale al numero di input
Elementi rendono più facile iterare attraverso di esso.
Per illustrare questo punto, confronta i seguenti due implessioni Python
mentazioni di una funzione che legge un numero intero n seguito dalla lettura
numeri interi A1, A2, ..., an.
La prima implementazione utilizza un array basato su 1 A.
n = int (stdin.readline ())
A = [nessuno] \* (n + 1)
per i nell'intervallo (1, n + 1):
A [i] = int (stdin.readline ())
Il secondo utilizza un array basato su 0 A.
n = int (stdin.readline ())
A = [nessuno] \* n
per i in gamma (len (a)):
A [i] = int (stdin.readline ())
Usa intervalli semiopen.
Ricordiamo che l'algoritmo Mergesort prima ordina la metà sinistra del
Dato l'array, quindi ordina la seconda metà e finalmente unisce il ribasso
SULTS.L'implementazione ricorsiva di questo algoritmo, indicata di seguito,

---
layout: 
title: Pagina 69
level: 3
---


50
Capitolo 3. Sfide di programmazione
prende un array A e due indici L e R e ordina il Subarray
A [l..r].Cioè, ordina l'intervallo chiuso [l, r] = {l, l+1, ..., r} di a quello
Include entrambi i confini L e R.
Mergesort (a, l, r):
Se L −R + 1 ≤1:
ritorno
m ← ⌊l+r
2 ⌋
Mergesort (a, l, m)
Mergesort (A, M + 1, R)
Merge (a, l, m, r)
Un intervallo semiopeno include il confine sinistro ed esclude la destra
Confine: [l, r) = {l, l + 1, ..., r −1}.Usando semiopen invece che chiuso
Gli intervalli riducono le possibilità di commettere un errore per uno, perché:
1. Il numero di elementi in un intervallo semiopen [L, R) è r −L (per
Un intervallo chiuso [L, R], è r −L + 1).
2. È facile dividere un intervallo semiopen in due semiopen
Tervals: [l, r) = [l, m) ∪ [m, r) (per un intervallo chiuso [l, r], [l, r] =
[L, M] ∪ [M + 1, R]).
Confronta l'implementazione precedente con quella seguente.
Mergesort (a, l, r):
Se L −R ≤1:
ritorno
m ← ⌊l+r
2 ⌋
Mergesort (a, l, m)
Mergesort (a, m, r)
Merge (a, l, m, r)
Per un array a [0..n −1], la chiamata esterna per la prima implementazione
tation è mergesort (a, 0, n −1), mentre per il secondo è
Mergesort (a, 0, n).
Si noti inoltre che per le lingue con flusso intero, la linea

---
layout: 
title: Pagina 70
level: 3
---


3.4.Buone pratiche di programmazione
51
m ← ⌊l+r
2 ⌋
può produrre un risultato errato.Un modo più sicuro di calcolare il valore
di m è
M ← L + ⌊R - L
2 ⌋

---
layout: 
title: Pagina 71
level: 3
---


52
Capitolo 3. Sfide di programmazione

---
layout: 
title: Pagina 72
level: 3
---


Capitolo 4: riscaldamento algoritmico
In questo capitolo, imparerai che programmi basati su algoritmi efficienti
Può essere un miliardo di tempo più veloce dei programmi basati su algoritmi ingenui.
Imparerai come stimare il tempo di esecuzione e la memoria di un al-
Goritmo senza mai implementarlo.Armato di questa conoscenza, tu
sarà in grado di confrontare vari algoritmi, selezionare quelli più efficienti,
e implementali infine per risolvere varie sfide di programmazione!
1
1
2
3
5
Numero di fibonacci
F170 = 150804340016
807970735635
273952047185
Ultima cifra
di Fibonacci
Numero
10
2
6
Più grande
Divisore comune
30
2
3
5
6
15
10
Meno
Multiplo comune
FN Mod 3
0
0
1
1
1
1
2
2
3
0
5
2
8
2
13
1
Fibonacci
Numero di nuovo
1 + 1 + 2 + 3 + 5 + 8 = 20
Ultima cifra di
la somma di
Numeri di fibonacci
2 + 3 + 5 + 8 + 13 = 31
Ultima cifra del
Somma di Fibonacci
Numeri di nuovo
53

---
layout: 
title: Pagina 73
level: 3
---


54
Capitolo 4. Riscaldamento algoritmico
4.1
Numero di fibonacci
Problema numero di Fibonacci
Calcola il numero N-Th Fibonacci.
Input: un numero intero n.
Output: numero N-Th Fibonacci.
1
1
2
3
5
I numeri di Fibonacci sono definiti in modo ricorsivo:
Fn =







N
Se n è 0 o 1
Fn - 1 + fn - 2
Se n ≥2
con conseguente seguente algoritmo ricorsivo:
Fibonacci (n):
Se n ≤1:
restituire n
restituire fibonacci (n −1) + fibonacci (n −2)
Implementa questo algoritmo e prova a calcolare F40.Lo vedrai
Ci vuole già tempo significativo.E il sole potrebbe morire davanti al tuo computer
Restituisce F150 poiché i computer moderni hanno bisogno di miliardi di anni per calcolare
questo numero...
Per capire perché questo algoritmo è così lento, prova a calcolare F20 a
http://www.cs.usfca.edu/˜galles/visualization/dpfib.html.
Immettere "20" e premere il pulsante "Fibonacci ricorsivo".Vedrai
Una serie apparentemente infinita di chiamate ricorsive.Ora, premere "Salta in avanti"
per fermare l'algoritmo ricorsivo e chiamare l'algoritmo iterativo premendo
"Tabella Fibonacci".Questo calcolerà immediatamente F20.(Nota che il Visu-
Alization utilizza una definizione leggermente diversa dei numeri di fibonacci: f0 = 1
invece di f0 = 0.)

---
layout: 
title: Pagina 74
level: 3
---


4.1.Numero di fibonacci
55
Formato di input.Un numero intero n.
Formato di output.Fn.
Vincoli.0 ≤n ≤45.
Campione 1.
Ingresso:
3
Produzione:
2
Campione 2.
Ingresso:
10
Produzione:
55
Limiti di tempo e memoria.Quando i limiti di tempo/memoria non vengono specificati,
Utilizziamo i valori predefiniti specificati nella Sezione 3.3.1.

---
layout: 
title: Pagina 75
level: 3
---


56
Capitolo 4. Riscaldamento algoritmico
4.2
Ultima cifra del numero di fibonacci
Ultima cifra del problema numero di Fibonacci
Calcola l'ultima cifra del numero di n-th fibonacci
ber.
Input: un numero intero 0 ≤n ≤105.
Output: l'ultima cifra dell'N-Th
Numero di fibonacci.
F170 = 150804340016
807970735635
273952047185
Per risolvere questo problema, calcoliamo FN e semplicemente producia la sua ultima cifra:
FibonaCcilastDigit (N):
F [0] ← 0
F [1] ← 1
per io da 2 a n:
F [i] ← f [i −1] + f [i −2]
restituire f [n] mod 10
Si noti che i numeri di Fibonacci crescono rapidamente.Per esempio,
F100 = 354224848179261915075.
Pertanto, se si utilizza i tipi C ++ Int32 T o Int64 T per la conservazione di F, lo farai
Colpisci rapidamente un flusso intero.Se raggiungi la precisione arbitraria
Numeri, come il biginteger di Java, o i numeri interi integrati di Pythons, noterai
che il ciclo funziona molto più lento quando il numero di iterazione aumenta.
Per aggirare questo problema, invece di immagazzinare il numero di i-th fibonacci
In F [i] memorizzeremo solo l'ultima cifra di Fi, cioè sostituiamo il corpo del
per loop con quanto segue:
F [i] ← (f [i −1] + f [i −2]) mod 10
Successivamente, calcolando la somma dei numeri a singola cifra F [I - 1] e F [I - 2]
sarà veloce.
Formato di input.Un numero intero n.

---
layout: 
title: Pagina 76
level: 3
---


4.2.Ultima cifra del numero di fibonacci
57
Formato di output.L'ultima cifra di FN.
Vincoli.0 ≤n ≤106.
Campione 1.
Ingresso:
3
Produzione:
2
F3 = 2.
Campione 2.
Ingresso:
139
Produzione:
1
F139 = 50095301248058391139327916261.
Campione 3.
Ingresso:
91239
Produzione:
6
F91239 impiegherà più di dieci pagine per rappresentare, ma la sua ultima cifra
è uguale a 6.

---
layout: 
title: Pagina 77
level: 3
---


58
Capitolo 4. Riscaldamento algoritmico
4.3
Massimo comun divisore
Il più comune problema di divisore comune
Calcola il più grande divisore comune di due pos-
numeri interi.
Input: due numeri interi positivi.
Produzione:
Il loro più grande comune
divisore.
10
2
6
Il più grande divisore comune GCD (a, b) di due numeri interi positivi A e B
è il numero intero più grande D che divide sia a che b.La soluzione del grande-
EST il problema del divisore comune è stato prima descritto (ma non scoperto!)
Il matematico greco Euclide venticinque secoli fa.Ma il nome
di un matematico che ha scoperto questo algoritmo, un secolo prima dell'euclide
lo ha descritto, rimane sconosciuto.Secoli dopo, l'algoritmo di Euclid è stato
scoperto dagli astronomi indiani e cinesi.Ora, algoritmo e ﬃ cient
Per calcolare il più grande divisore comune è un ingrediente importante di
Algoritmi crittografici moderni.
Il tuo obiettivo è implementare l'algoritmo di Euclid per il calcolo del GCD.
Formato di input.Numeri interi A e B (separati da uno spazio).
Formato di output.GCD (A, B).
Vincoli.1 ≤a, b ≤2 · 109.
Campione.
Ingresso:
28851538 1183019
Produzione:
17657
28851538 = 17657 · 1634, 1183019 = 17657 · 67.

---
layout: 
title: Pagina 78
level: 3
---


4.4.Minimo comune multiplo
59
4.4
Minimo comune multiplo
Problema multiplo meno comune
Calcola il multiplo meno comune di due positivi
numeri interi.
Input: due numeri interi positivi.
Output: il loro mulo meno comune
tiple.
30
2
3
5
6
15
10
Il LCM multiplo meno comune (a, b) di due numeri interi positivi a e b
è il numero più piccolo m che è divisibile sia da a e b.
Fermati e pensa.In che modo LCM (A, B) è correlato al GCD (A, B)?
Formato di input.Numeri interi A e B (separati da uno spazio).
Formato di output.LCM (A, B).
Vincoli.1 ≤a, b ≤2 · 109.
Campione 1.
Ingresso:
6 8
Produzione:
24
Tra tutti i numeri interi positivi che sono divisibili sia da 6 che da 8 (ad esempio,
48, 480, 24), 24 è il più piccolo.
Campione 2.
Ingresso:
28851538 1183019
Produzione:
1933053046
1 933 053 046 è il più piccolo intero positivo divisibile da entrambi
28 851 538 e 1 183 019.

---
layout: 
title: Pagina 79
level: 3
---


60
Capitolo 4. Riscaldamento algoritmico
4.5
Numero di Fibonacci di nuovo
Numero di fibonacci di nuovo problema
Calcola il modulo numero N-Th Fibonacci m.
Input: numeri interi 0 ≤n ≤1018 e
2 ≤m ≤105.
Output: N-Th Fibonacci Modulo m.
FN Mod 3
0
0
1
1
1
1
2
2
3
0
5
2
8
2
13
1
In questo problema, n può essere così grande che un algoritmo che si aggira per
N iterazioni saranno troppo lente.Pertanto dobbiamo evitare un tale ciclo.A
Ottieni un'idea di come risolvere questo problema senza attraversare tutti i fibonacci
numeri fi per i da 0 a n, dai un'occhiata al tavolo qui sotto:
io
0
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
Fi
0
1
1
2
3
5
8
13
21
34
55
89
144
233
377
610
FI Mod 2
0
1
1
0
1
1
0
1
1
0
1
1
0
1
1
0
FI Mod 3
0
1
1
2
0
2
2
1
0
1
1
2
0
2
2
1
Fermati e pensa.Vedi proprietà interessanti degli ultimi due
righe nella tabella sopra?
Entrambe queste sequenze sono periodiche!Per m = 2, il periodo è 011 e ha
lunghezza 3, mentre per m = 3 il periodo è 01120221 e ha lunghezza 8.
io
0
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
Fi
0
1
1
2
3
5
8
13
21
34
55
89
144
233
377
610
FI Mod 2
0
1
1
0
1
1
0
1
1
0
1
1
0
1
1
0
FI Mod 3
0
1
1
2
0
2
2
1
0
1
1
2
0
2
2
1
Pertanto, per calcolare, diciamo, F2015 MOD 3 dobbiamo solo trovare il ri-
Mainder del 2015 se diviso per 8. dal 2015 = 251 · 8 + 7, concludiamo
Quel F2015 Mod 3 = F7 Mod 3 = 1.

---
layout: 
title: Pagina 80
level: 3
---


4.5.Numero di Fibonacci di nuovo
61
Si scopre che per qualsiasi intero m ≥2, la sequenza fn mod m è pe-
riodico.Il periodo inizia sempre con 01 ed è noto come periodo Pisano
(Pisano è un altro nome di Fibonacci).
Pausa di esercizio.Qual è il periodo di Fi Mod 5?
Pausa di esercizio.Dimostrare che Fi mod M è periodico per ogni m.
Pausa di esercizio.Dimostrare che il periodo di FI Mod M non supera M2.
Formato di input.Numeri interi n e m.
Formato di output.Fn mod m.
Vincoli.1 ≤n ≤1018, 2 ≤m ≤105.
Campione 1.
Ingresso:
1 239
Produzione:
1
F1 Mod 239 = 1 Mod 239 = 1.
Campione 2.
Ingresso:
115 1000
Produzione:
885
F115 Mod 1000 = 483162952612010163284885 Mod 1000 = 885.
Campione 3.
Ingresso:
2816213588 30524
Produzione:
10249
F2816213588 richiederebbe a centinaia di pagine di scriverlo, ma
F2816213588 MOD 30524 = 10249.

---
layout: 
title: Pagina 81
level: 3
---


62
Capitolo 4. Riscaldamento algoritmico
4.6
Ultima cifra della somma dei numeri di fibonacci
Ultima cifra della somma dei numeri di fibonacci
Problema
Calcola l'ultima cifra di f0 + f1 + ··· + fn.
Input: intero 0 ≤n ≤1018.
Output: l'ultima cifra di F0 + F1 +
··· + fn.
1 + 1 + 2 + 3 + 5 + 8 = 20
Suggerimento.
Poiché l'approccio della forza bruta per questo problema è troppo lento, prova a farlo
Elaborare una formula per f0+f1+f2+···+fn.Gioca con piccoli valori di n
Per ottenere un'idea e utilizzare una soluzione per il problema precedente in seguito.
Formato di input.Intero n.
Formato di output.(F0 + F1 + ··· + FN) Mod 10.
Vincoli.0 ≤n ≤1018.
Campione 1.
Ingresso:
3
Produzione:
4
F0 + F1 + F2 + F3 = 0 + 1 + 1 + 2 = 4.
Campione 2.
Ingresso:
100
Produzione:
5
F0 + ··· + F100 = 92737269219307899175.

---
layout: 
title: Pagina 82
level: 3
---


4.7.Ultima cifra della somma dei numeri di fibonacci di nuovo
63
4.7
Ultima cifra della somma dei numeri di fibonacci
Ancora
Ultima cifra della somma parziale di Fibonacci
Problema dei numeri
Calcola l'ultima cifra di FM + FM + 1 + ··· + fn.
Input: numeri interi m e n.
Produzione:
L'ultima cifra di FM +
Fm + 1 + ··· + fn.
2 + 3 + 5 + 8 + 13 = 31
Formato di input.Numeri interi m e n.
Formato di output.(FM + FM + 1 + ··· + FN) Mod 10.
Vincoli.0 ≤m ≤n ≤1018.
Campione 1.
Ingresso:
3 7
Produzione:
1
F3 + F4 + F5 + F6 + F7 = 2 + 3 + 5 + 8 + 13 = 31.
Campione 2.
Ingresso:
10 10
Produzione:
55
F10 = 55.

---
layout: 
title: Pagina 83
level: 3
---


64
Capitolo 4. Riscaldamento algoritmico

---
layout: 
title: Pagina 84
level: 3
---


Capitolo 5: Algoritmi avidi
In questo capitolo imparerai a conoscere apparentemente ingenuo ma potente avido
Algoritmi.Dopo aver appreso l'idea chiave dietro gli avidi algoritmi,
Alcuni dei nostri studenti sentono di rappresentare l'esercito svizzero algoritmico
coltello che può essere applicato per risolvere quasi tutte le sfide di programmazione
questo libro.Essere avvertito: poiché questa idea intuitiva funziona raramente in pratica, tu
Devo dimostrare che il tuo avido algoritmo produce una soluzione ottimale!
¢ 1
¢ 5
¢ 10
Cambio di moneta
Valore massimo
del bottino
clic
prezzi
30
20
10
5
3
2
Adver massimo
entrate per tese
Raccolta
Firme
8
1
2
5
Massimo
Numero di premi
Riprendere
Stipendio massimo
65

---
layout: 
title: Pagina 85
level: 3
---


66
Capitolo 5. Algoritmi avidi
5.1
Cambio di moneta
Problema di cambio di denaro
Calcola il numero minimo di monete necessarie
per cambiare il valore dato in monete con denom-
Inazioni 1, 5 e 10.
Input: denaro intero.
Produzione:
Il numero minimo
di monete con denominazioni 1, 5,
e 10 che cambia denaro.
¢ 1
¢ 5
¢ 10
In questo problema, implementerai un semplice algoritmo avido utilizzato
da cassieri di tutto il mondo.Supponiamo che un cassiere abbia illimitato
Numero di monete di ogni denominazione.
Formato di input.Denaro intero.
Formato di output.Il numero minimo di monete con denominazioni 1, 5,
10 che cambia denaro.
Vincoli.1 ≤money ≤103.
Campione 1.
Ingresso:
2
Produzione:
2
2 = 1 + 1.
Campione 2.
Ingresso:
28
Produzione:
6
28 = 10 + 10 + 5 + 1 + 1 + 1.

---
layout: 
title: Pagina 86
level: 3
---


5.1.Cambio di moneta
67
Soluzione
Ecco l'idea: mentre denaro> 0, continua a prendere una moneta con la più grande de-
Nomina che non supera il denaro, sottraendo il suo valore dal denaro,
e aggiungendo 1 al conteggio del numero di monete:
ChangeMoney (denaro):
NUMCOINS ← 0
mentre denaro> 0:
Se denaro ≥10:
denaro ← denaro −10
altro se denaro ≥5:
denaro ← denaro −5
altro:
denaro ← denaro −1
NUMCOINS ← NUMCOINS + 1
restituire numcoin
C'è anche un liner per risolvere questo problema:
restituzione ⌊money/10⌋+ ⌊ (Money Mod 10)/5⌋+ (Money Mod 5)
Progettare algoritmi avidi è facile, ma dimostrare che funzionano è
Dieci non banali!Probabilmente ti stai chiedendo perché dovremmo perdere tempo
dimostrando la correttezza dell'ovvio algoritmo di ChangeMoney.Aspetta
fino a quando non impostiamo una trappola algoritmica per convincerti che la prova di seguito
non è una perdita di tempo!
Per dimostrare che questi algoritmi avidi è corretto, mostriamo che prendendo
Una moneta con la più grande denominazione è coerente con un po 'di così- ottimale
lution.Cioè dobbiamo dimostrare che per qualsiasi denaro intero positivo lì
esiste un modo ottimale per cambiare denaro che utilizza almeno una moneta con
denominazione d, dove d è il numero più grande tra 1,5,10
non superare il denaro.Lo dimostriamo considerando alcuni casi.In ciascuno di
i casi che prendiamo una soluzione (cioè un cambiamento particolare per il denaro) e
trasformarlo in modo che il numero di monete non aumenti e contiene
almeno una moneta con denominazione D. In particolare, se partiamo da un
Il modo ottimale per cambiare denaro ciò che otteniamo è anche un modo ottimale di Chang-
denaro che contiene una moneta D.
1. 1 ≤money <5. In questo caso d = 1 e l'unico modo per cambiare denaro
è usare monete di denaro della denominazione 1.

---
layout: 
title: Pagina 87
level: 3
---


68
Capitolo 5. Algoritmi avidi
2. 5 ≤money <10. In questo caso d = 5. Chiaramente, qualsiasi cambio di denaro
usa solo monete con denominazioni 1 e 5. Se non usa un
moneta con denominazione 5, quindi usa almeno cinque monete di denom-
inazione 1 (dal denaro ≥5).Sostituendoli con una moneta di
Denominazione 5 miglioriamo questa soluzione.
3. 10 ≤money.In questo caso D = 10. Considera un modo per cambiare denaro
e supponiamo che non usi una moneta 10. Un semplice, ma cruciale
l'osservazione è che alcuni sottoinsieme delle monete usate somme fino a 10. questo
può essere mostrato considerando il numero di monete di denominazione 5
In questa soluzione: se non ci sono 5, allora ci sono almeno dieci 1 e
Li sostituiamo con un singolo 10;Se ce n'è esattamente uno 5, allora lì
sono almeno cinque cinque e li sostituiamo di nuovo con un solo 10;Se
Ci sono almeno due 5, possono essere nuovamente sostituiti.
Sebbene questa prova sia lunga e piuttosto noiosa, hai bisogno di una prova
È ora che ti venga in mente un algoritmo avido!La prossima pausa di esercizio suggerisce
Un modo più compatto per dimostrare la correttezza dell'algoritmo sopra.
Pausa di esercizio.Mostra che le monete di denaro Mod 5 della denominazione 1 sono
necessario in qualsiasi soluzione e che il resto dovrebbe essere cambiato con monete di
denominazione 10 e al massimo una moneta di denominazione 5.
Tempo di esecuzione.Il tempo di esecuzione del primo algoritmo (con il tempo
Loop) è solo O (m), mentre il secondo algoritmo richiede solo pochi arith-
operazioni metiche.
Fermati e pensa.Questo avido algoritmo funziona per le denominazioni 1,
4 e 6?

---
layout: 
title: Pagina 88
level: 3
---


5.2.Valore massimo del bottino
69
5.2
Valore massimo del bottino
Massimizzare il valore del problema del bottino
Trova il valore massimo degli elementi che si adattano al
zaino.
Ingresso:
La capacità di un retro
Passare w e i pesi
(W1, ..., WN) e per sterline
(P1, ..., PN)
Di
N
diverso
com
sterline.
Output: il prezzo totale massimo
di articoli che si adattano allo zaino
della capacità data: cioè il massimo
Valore imum di p1 · u1 + ··· + pn · un
tale che U1 + ··· + un ≤w e 0 ≤
Ui ≤wi per tutti i.
Un ladro si rompe in un negozio di spezie e trova quattro chili di sa ﬀ ron, tre
chili di vaniglia e cinque chili di cannella.Il suo zaino si adatta a
La maggior parte delle nove sterline, quindi non può prendere tutto.Supponendo che
I prezzi di Sa ﬀ ron, vaniglia e cannella sono $ 5 000, $ 200 e $ 10 per
Pound rispettivamente, qual è il bottino più prezioso in questo caso?Se il ladro
prende u1 chili di sa ﬀ ron, u2 libbre di vaniglia e u3 chili di cinna
Lun, il prezzo totale del bottino è 5000 · U1 + 200 · U2 + 10 · U3.Il ladro
vorrebbe massimizzare il valore di questa espressione soggetta al seguito
vincoli ing: u1 ≤4, u2 ≤3, u3 ≤5, u1 + u2 + u3 ≤9.
Formato di input.La prima riga dell'input contiene il numero N di
chili e la capacità W di uno zaino.Le successive n linee definiscono
i prezzi e i pesi dei composti.La riga I-Th contiene il
Prezzo per libbra pi e il peso con il composto i-th.
Formato di output.Produrre il prezzo massimo dei composti che si adattano
lo zaino.
Vincoli.1 ≤n ≤103, 0 ≤w ≤2 · 106;0 ≤pi ≤2 · 106, 0 <Wi ≤2 · 106
per tutti 1 ≤i ≤n.Tutti i numeri sono numeri interi.

---
layout: 
title: Pagina 89
level: 3
---


70
Capitolo 5. Algoritmi avidi
Campane e fischi.Sebbene l'input a questo problema consista di integrare
Gers, l'output può essere non integrato.Pertanto, il valore assoluto
della differenza tra la risposta del tuo programma e l'opti
Il valore Mal dovrebbe essere al massimo 10-3.Per garantire questo, produrre il tuo
swer con almeno quattro cifre dopo il punto decimale (altrimenti il ​​tuo
Rispondere, mentre viene calcolato correttamente, può rivelarsi sbagliato
a causa di problemi di arrotondamento).
Campione 1.
Ingresso:
3 50
60 20
100 50
120 30
Produzione:
180.0000
Per ottenere il valore 180, il ladro prende l'intero composto
e l'intero terzo composto.
Campione 2.
Ingresso:
1 10
500 30
Produzione:
166.6667
Il ladro dovrebbe richiedere dieci chili dell'unico composto disponibile.

---
layout: 
title: Pagina 90
level: 3
---


5.3.Entrate della pubblicità massima
71
5.3
Entrate della pubblicità massima
Prodotto massimo di due sequenze Proba
Lem
Trova il prodotto massimo punti di due sequenze
di numeri.
Input: due sequenze di n posi-
numeri interi: Price1, ..., Pricen e
Clicks1, ..., clicksn.
Produzione:
IL
massimo
valore
di Price1 · C1 + ··· + Pricen · CN,
dove c1, ..., cn è una permutazione di
Clicks1, ..., clicksn.
clic
prezzi
30
20
10
5
3
2
Hai n = 3 slot pubblicitari sulla tua popolare pagina Internet
E vuoi venderli agli inserzionisti.
Si aspettano, rispettivamente,
Clicks1 = 10, clics2 = 20 e clic su 3 = 30 clic al giorno.Ne hai trovati tre
inserzionisti disposti a pagare Price1 = $ 2, Price2 = $ 3 e Price3 = $ 5 per
clic.Come abbinare gli slot e gli inserzionisti?Ad esempio, il
L'accoppiamento blu fornisce entrate di 10 · 5+20 · 2+30 · 3 = 180 dollari, mentre il
Black One produce entrate di 10 · 3 + 20 · 5 + 30 · 2 = 190 dollari.
Formato di input.La prima linea contiene un numero intero n, il secondo
fa una sequenza di numeri interi price1, ..., pricen, il terzo contiene
Una sequenza di numeri interi clicks1, ..., clicksn.
Formato di output.Output Il valore massimo di (Price1 · C1+···+Pricen · CN),
dove C1, ..., CN è una permutazione di clicks1, ..., clic.
Vincoli.1 ≤n ≤103;0 ≤pricei, clicsi ≤105 per tutti 1 ≤i ≤n.

---
layout: 
title: Pagina 91
level: 3
---


72
Capitolo 5. Algoritmi avidi
Campione 1.
Ingresso:
1
23
39
Produzione:
897
897 = 23 · 39.
Campione 2.
Ingresso:
3
2 3 9
7 4 2
Produzione:
79
79 = 7 · 9 + 2 · 2 + 3 · 4.

---
layout: 
title: Pagina 92
level: 3
---


5.4.Raccolta delle firme
73
5.4
Raccolta delle firme
Coprire i segmenti per problema di punti
Trova il numero minimo di punti necessari per
Coprire tutti i segmenti dati su una linea.
Input: una sequenza di n segmenti
[A1, B1], ..., [an, bn] su una linea.
Output: un insieme di punti di mini-
dimensione della mamma in modo tale che ogni segmento
[AI, Bi] contiene un punto, cioè lì
esiste un punto x tale che ai ≤x ≤
bi.
Sei responsabile della raccolta di firme da tutti gli inquilini in
un edificio.Per ogni inquilino, conosci un periodo di tempo in cui lui o lei
è a casa.Vorresti raccogliere tutte le firme visitando l'edificio
il più delle volte possibile.Per semplicità, supponiamo che quando entri
l'edificio, raccogli istantaneamente le firme di tutti gli inquilini che si trovano
l'edificio in quel momento.
Formato di input.La prima riga dell'ingresso contiene il numero n di Seg-
menti.Ciascuna delle seguenti linee N contiene due numeri interi AI e BI
(separato da uno spazio) che definisce le coordinate degli endpoint del
I-th segmento.
Formato di output.Il numero minimo M di punti sulla prima linea e
le coordinate interi di M punti (separate da spazi) sul sec-
linea e.È possibile produrre i punti in qualsiasi ordine.Se ce ne sono molti
Tali set di punti, è possibile produrre qualsiasi set.
Vincoli.1 ≤n ≤100;0 ≤i ≤bi ≤109 per tutti i.

---
layout: 
title: Pagina 93
level: 3
---


74
Capitolo 5. Algoritmi avidi
Campione 1.
Ingresso:
3
1 3
2 5
3 6
Produzione:
1
3
Tutti e tre i segmenti [1,3], [2,5], [3,6] contengono il punto con
Coordinata 3.
Campione 2.
Ingresso:
4
4 7
1 3
2 5
5 6
Produzione:
2
3 6
Il secondo e il terzo segmenti contengono il punto con coordinamento
nate 3 mentre il primo e il quarto segmenti contengono il punto
con coordinate 6. Tutti i segmenti non possono essere coperti da un singolo punto,
Poiché i segmenti [1,3] e [5,6] non si sovrappongono.Un altro valido
La soluzione in questo caso è l'insieme di punti 2 e 5.

---
layout: 
title: Pagina 94
level: 3
---


5.5.Numero massimo di premi
75
5.5
Numero massimo di premi
Problema distinto Sumands
Rappresentare un numero intero positivo come somma del
Numero massimo di distinti a coppie positivi
numeri interi.
Input: intero positivo n.
Produzione:
Il massimo k tale
che n può essere rappresentato come il
somma a1 + ··· + ak di k distinto inte-
Gers.
8
1
2
5
Stai organizzando una competizione per i bambini e hai n carati
dare come premi.Vorresti usare queste caramelle per i migliori k posti
una competizione con una restrizione che un posto più alto ottiene un numero maggiore
di caramelle.Per rendere felice il maggior numero possibile di bambini, devi trovare
Il valore più grande di K per il quale è possibile.
Formato di input.Intero n.
Formato di output.Nella prima riga, produrre il numero massimo k in modo tale
n può essere rappresentato come la somma di K investy bid-widy positiva
Gers.Nella seconda riga, output k interi positivi distinti a coppie a coppie
tale somma fino a n (se ci sono molte di queste rappresentazioni, output
di loro).
Vincoli.1 ≤n ≤109.
Campione 1.
Ingresso:
6
Produzione:
3
1 2 3

---
layout: 
title: Pagina 95
level: 3
---


76
Capitolo 5. Algoritmi avidi
Campione 2.
Ingresso:
8
Produzione:
3
1 2 5
Campione 3.
Ingresso:
2
Produzione:
1
2

---
layout: 
title: Pagina 96
level: 3
---


5.6.Stipendio massimo
77
5.6
Stipendio massimo
Problema concatenato più grande
Compilare il numero più grande concatenando il
Dai numeri.
Input: una sequenza di interazioni positive
Gers.
Output: il numero più grande che
può essere ottenuto concatenando
I numeri interi dati in qualche ordine.
Riprendere
Questo è probabilmente il problema più importante in questo libro :).Come l'ultimo
Domanda di un'intervista, il tuo futuro capo ti dà alcuni pezzi di carta
con un singolo numero scritto su ciascuno di essi e ti chiede di comporre
un numero maggiore da questi numeri.Il numero risultante sta per
Sii il tuo stipendio, quindi sei molto motivato a risolvere questo problema!
Questo è un semplice algoritmo avido:
Più grandeConcatenate (numeri):
TUELARIO ← Stringa vuota
Mentre i numeri non sono vuoti:
maxnumber ← −∞
Per ogni numero in numeri:
se numero ≥maxnumero:
maxnumber ← numero
Aggiungi MaxNumber a Yoursalary
Rimuovi MaxNumber dai numeri
Restituisci il tuolario
Sfortunatamente, questo algoritmo non massimizza sempre il tuo stipendio!
Ad esempio, per un input composto da due numeri interi 23 e 3 ritorna
233, mentre il numero più grande è 323.
Pausa di esercizio.Dimostrare che l'algoritmo funziona correttamente per il caso di
Numeri a una cifra.
Non preoccuparti, tutto ciò che devi fare per massimizzare il tuo stipendio è sostituire

---
layout: 
title: Pagina 97
level: 3
---


78
Capitolo 5. Algoritmi avidi
la linea
se numero ≥maxnumero:
con la seguente riga:
Se isbetter (numero, maxnumber):
Per una funzione adeguatamente implementata isbetter.Ad esempio, isbet-
Ter (3, 23) dovrebbe restituire vero.
Fermati e pensa.Come implederesti ISBetter?
Formato di input.La prima riga dell'input contiene un numero intero n.Il secondo
La linea contiene numeri interi A1, ..., an.
Formato di output.Il numero più grande che può essere composto da A1, ..., an.
Vincoli.1 ≤n ≤100;1 ≤i ≤103 per tutti 1 ≤i ≤n.
Campione 1.
Ingresso:
2
21 2
Produzione:
221
Si noti che in questo caso l'algoritmo di cui sopra restituisce anche un errato
Risposta 212.
Campione 2.
Ingresso:
5
9 4 6 1 9
Produzione:
99641
L'input è costituito solo da numeri a una cifra, quindi l'algoritmo
Sopra restituisce la risposta corretta.

---
layout: 
title: Pagina 98
level: 3
---


5.6.Stipendio massimo
79
Campione 3.
Ingresso:
3
23 39 92
Produzione:
923923
L'algoritmo (errato) più grande produce comunque
La risposta corretta in questo caso, un altro promemoria da dimostrare sempre
La correttezza dei tuoi avidi algoritmi!

---
layout: 
title: Pagina 99
level: 3
---


80
Capitolo 5. Algoritmi avidi

---
layout: 
title: Pagina 100
level: 3
---


Capitolo 6: Divide-and-Conquer
In questo capitolo, imparerai a conoscere gli algoritmi di divisione
ti aiuterà a cercare enormi database un milione di volte più velocemente di Brute-
Algoritmi di forza.Armato di questa tecnica algoritmica, imparerai in
I nostri mooc Coursera ed EDX che il modo standard per moltiplicare i numeri
(che hai imparato nella scuola elementare) è lungi dall'essere il più veloce!Noi
applicherà quindi la tecnica di divisione e conquista per progettare un selezione rapida
Algoritmi.Imparerai che questi algoritmi sono ottimali, cioè anche
Il leggendario informatica Alan Turing non sarebbe in grado di progettare
Un algoritmo di smistamento più veloce!
1
3
7
8
9 12 15
1
3
7
8
9 12 15
1
3
7
8
9 12 15
Ricerca binaria
Elemento a maggioranza
Miglioramento
Quicksort
3
2
5
9
4
Numero di
Inversioni
1
0
2
1
Organizzare
una lotteria
Punti più vicini
81

---
layout: 
title: Pagina 101
level: 3
---


82
Capitolo 6. Divide-and-Conquer
6.1
Ricerca binaria
Prima di implementare l'algoritmo di ricerca binaria, prova a risolvere il nostro orologio
Puzzle di gioco in cui fai ripetute ipotesi sul prezzo di un articolo,
con il computer che ti dice solo se il prezzo reale è più alto o
inferiore all'ipotesi più recente.Una possibile strategia per l'orologio
Il gioco è quello di scegliere una serie di prezzi entro i quali il prezzo dell'articolo deve scendere,
E poi indovina un prezzo a metà strada tra questi due estremi.Se questa ipotesi è
Errato, quindi elimini immediatamente la metà dei possibili prezzi.Voi
Quindi fai un'ipotesi nella gamma centrale dei restanti prezzi possibili,
eliminando di nuovo metà di loro.Iterare questa strategia produce rapidamente il
prezzo dell'articolo.
Questa strategia per il gioco dell'orologio motiva un algoritmo di ricerca binaria
Per trovare la posizione di un elemento Q all'interno di un array ordinato K.
Implementa questo algoritmo, provi a risolvere il nostro puzzle di colori opposti.
Problema di ricerca dell'array ordinato
Cerca una chiave in un array ordinato di chiavi.
Ingresso:
UN
smistato
vettore
K
=
[k0, ..., kn - 1] di numeri interi distinti
(cioè, k0 <k1 <··· <kn- 1) e un in-
teger q.
Output: controlla se si verifica Q
in K.
1
3
7
8
9 12 15
1
3
7
8
9 12 15
1
3
7
8
9 12 15
Un modo ingenuo per risolvere questo problema è scansionare l'array k (run-
tempo ning o (n)).
L'algoritmo binarysearch seguente risolve il problema
Lem in o (logn) tempo.È inizializzato impostando minindex pari a 0 e
maxindex pari a n −1.Imposta midindex su (minindex + maxindex)/2
e quindi controlla se Q è maggiore o inferiore a K [Midindex].
Se Q è più grande di questo valore, allora BinarySearch scorre sul subarray
di K da Minindex a Midindex −1;altrimenti, si itetera sul subar-
raggio di k da midindex + 1 a maxindex.Iterazione alla fine identifica
Se Q si verifica in K.

---
layout: 
title: Pagina 102
level: 3
---


6.1.Ricerca binaria
83
BinarySearch (k [0..n −1], q)
Minindex ← 0
maxindex ← n −1
mentre maxindex ≥inindex:
Midindex ← ⌊ (minindex + maxindex)/2⌋
Se k [midindex] = Q:
restituire Midindex
altrimenti se k [midindex] <q:
Minindex ← Midindex + 1
altro:
maxindex ← midindex −1
restituire "chiave non trovata"
Ad esempio, se q = 9 e k = [1,3,7,8,9,12,15], BinarySearch farebbe
prima set minIndex = 0, maxIndex = 6 e midindex = 3.
Poiché Q è
maggiore di k [midindex] = 8, esaminiamo il subarray i cui elementi
sono maggiori di k [midindex] impostando minindex = 4, in modo che Midindex sia
ricompenso come (4+6)/2 = 5. Questa volta, Q è più piccolo di k [midindex] = 12,
E così esaminiamo il sottorray i cui elementi sono più piccoli di questo
valore.Questo subarray è costituito da un singolo elemento, che è q.
Il tempo di esecuzione di BinarySearch è O (logn) poiché riduce il
lunghezza del subarray di almeno un fattore 2 ad ogni iterazione del
mentre loop.Si noti tuttavia che il nostro sistema di classificazione non è in grado di controllare
Sia che tu abbia implementato un algoritmo O (Logn) veloce per l'array ordinato
Cerca o un algoritmo O (N) ingenuo.Il motivo è che qualsiasi programma ha bisogno
Un tempo lineare per leggere semplicemente i dati di input.Per questo motivo, chiediamo
si può risolvere il seguente problema più generale.
Array ordinato Problema di ricerca multipli
Cerca più tasti in una sequenza ordinata di chiavi.
Input: un array ordinato k = [k0, ..., kn - 1] di numeri interi distinti e
Un array Q = {Q0, ..., QM - 1} di numeri interi.
Output: per ogni Qi, controlla se si verifica in K.
Formato di input.La prima riga dell'input contiene un numero intero n e un se-
Quence K0 <k1 <... <kn - 1 di n distinti interi positivi in ​​aumento

---
layout: 
title: Pagina 103
level: 3
---


84
Capitolo 6. Divide-and-Conquer
ordine.La riga successiva contiene un numero intero M e M positivo
Q0, Q1, ..., QM - 1.
Formato di output.Per tutti i da 0 a m −1, output un indice 0 ≤j ≤n −1
tale che kj = qi o −1, se non esiste tale indice.
Vincoli.1 ≤n, m ≤104;1 ≤ki ≤109 per tutti 0 ≤i <n;1 ≤qj ≤109 per
Tutti 0 ≤j <m.
Campione.
Ingresso:
5 1 5 8 12 13
5 8 1 23 1 11
Produzione:
2 0 -1 0 -1
Le query 8, 1 e 1 si verificano nelle posizioni 3, 0 e 0, rispettivamente, mentre
Le query 23 e 11 non si verificano nella sequenza delle chiavi.

---
layout: 
title: Pagina 104
level: 3
---


6.2.Elemento a maggioranza
85
6.2
Elemento a maggioranza
Problema dell'elemento di maggioranza
Controllare se una determinata sequenza di numeri con-
fa un elemento che appare più della metà di
i tempi.
Input: una sequenza di N interi.
Output: 1, se c'è un elemento
che si ripete più di n/2
volte e 0 altrimenti.
Ecco l'algoritmo ingenuo per risolvere il problema dell'elemento di maggioranza
con tempo di esecuzione quadratica:
Maggioranzaelement (a [1..n]):
per io da 1 a n:
CurrentElement ← A [i]
Contare ← 0
per j da 1 a n:
Se a [J] = CurrentElement:
CONTE ← Conte + 1
If Count> N/2:
Restituisci CurrentElement
restituire "Nessun elemento di maggioranza"
Suggerimento.
Come avrete già indovinato, questo problema può essere risolto
L'algoritmo di divisione e conquista nel tempo O (NLOGN).In effetti, se una sequenza
di lunghezza n contiene un elemento di maggioranza, quindi lo stesso elemento è anche
un elemento di maggioranza per una delle sue metà.Quindi, per risolvere questo problema
prima divisione una determinata sequenza in metà e risolverla ricorsivamente per ciascuno
metà.Vedi come combinare i risultati di due chiamate ricorsive?
Pausa di esercizio.Dimostrare che questa idea porta a un algoritmo con la corsa
Time O (NLOGN).
Formato di input.La prima linea contiene un numero intero n, quello successivo contiene

---
layout: 
title: Pagina 105
level: 3
---


86
Capitolo 6. Divide-and-Conquer
Una sequenza di N interi non negativi a1, ..., an.
Formato di output.Output 1 se la sequenza contiene un elemento che ap-
pere più di n/2 volte e 0 altrimenti.
Vincoli.1 ≤n ≤105;0 ≤i ≤109 per tutti 1 ≤i ≤n.
Campione 1.
Ingresso:
5
2 3 9 2 2
Produzione:
1
2 è l'elemento di maggioranza.
Campione 2.
Ingresso:
4
1 2 3 1
Produzione:
0
Questa sequenza non ha un elemento di maggioranza (si noti che il
L'elemento 1 non è un elemento di maggioranza).
Pausa di esercizio.Puoi progettare un algoritmo O (N) ancora più veloce?

---
layout: 
title: Pagina 106
level: 3
---


6.3.Miglioramento di QuickSort
87
6.3
Miglioramento di QuickSort
L'algoritmo QuickSort presentato in sec-
2,7 diventa lento nel caso in cui
L'array di input contiene molti elementi ripetuti
menti.Ad esempio, quando tutti gli elementi in
L'array di input è lo stesso, la partizione
La procedura divide l'array in due parti,
una parte vuota e l'altra parte con N - 1
elementi.Poiché Quicksort trascorre un tempo
Per eseguire questa partizione, la sua corsa generale
il tempo è:
a · n + a · (n −1) + a · (n −2) + ... = a · n · (n + 1)
2
.
Il tuo obiettivo è modificare l'algoritmo QuickSort in modo che funzioni anche velocemente
su sequenze contenenti molti elementi identici.
Formato di input.La prima riga dell'input contiene un numero intero n.Il prossimo
La linea contiene una sequenza di N interi A0, A1, ..., AN - 1.
Formato di output.Output questa sequenza ordinata in ordine non decrescente.
Vincoli.1 ≤n ≤105;1 ≤i ≤109 per tutti 0 ≤i <n.
Campione.
Ingresso:
5
2 3 9 2 2
Produzione:
2 2 2 3 9

---
layout: 
title: Pagina 107
level: 3
---


88
Capitolo 6. Divide-and-Conquer
6.4
Numero di inversioni
Numero di problemi di inversioni
Calcola il numero di inversioni in una sequenza
di numeri interi.
Ingresso:
Una sequenza di numeri interi
A1, ..., an.
Output: il numero di inversioni
nella sequenza, cioè il numero di
Indici i <j tale che ai> aj.
3
2
5
9
4
Il numero di inversioni in una sequenza misura la chiusura del se-
Queence è essere ordinata.Ad esempio, una sequenza ordinata nel non
L'ordine discendente non contiene inversioni, mentre una sequenza ordinata in
L'ordine discendente contiene N (n −1)/2 inversioni (ogni due elementi si formano
un'inversione).
Un algoritmo ingenuo per il numero di inversioni è passato
Tutte le possibili coppie (i, j) e hanno tempo di esecuzione O (N2).Risolvere questo problema
In Time O (NLOGN) usando la tecnica Divide-and-Conquer ha diviso l'input
Array in due metà e fai una chiamata ricorsiva su entrambe le metà.Che cosa
resta da fare è calcolare il numero di inversioni formate da
Due elementi da diverse metà.Se lo facciamo ingenuamente, questo porterà
Us torniamo a O (N2) tempo di esecuzione, poiché il numero totale di tali coppie è
N
2 · n
2 = N2
4 = O (N2).Si scopre che si può calcolare il numero di inver-
Sions formate da due elementi di diverse metà nel tempo O (n), se entrambi
Le metà sono già ordinate.Ciò suggerisce che invece di risolvere il origine
problema inal risolviamo un problema più generale: calcola il numero di
Inversioni nell'array dato e ordinarlo allo stesso tempo.
Pausa di esercizio.Modifica l'algoritmo Mergesort per risolvere questo problema
Lem.
Formato di input.La prima linea contiene un numero intero n, quello successivo contiene
Una sequenza di numeri interi A1, ..., an.
Formato di output.Il numero di inversioni nella sequenza.

---
layout: 
title: Pagina 108
level: 3
---


6.4.Numero di inversioni
89
Vincoli.1 ≤n ≤30000, 1 ≤i ≤109 per tutti 1 ≤i ≤n.
Campione.
Ingresso:
5
2 3 9 2 9
Produzione:
2
Le due inversioni qui sono (2,4) (A2 = 3> 2 = A4) e (3,4)
(A3 = 9> 2 = A4).

---
layout: 
title: Pagina 109
level: 3
---


90
Capitolo 6. Divide-and-Conquer
6.5
Organizzare una lotteria
Punti e segmenti problema
Dato un set di punti e una serie di segmenti
una riga, calcolare, per ogni punto, il numero di
segmenti in cui è contenuto.
Input: un set di segmenti e un set
di punti.
Output: il numero di segmenti
contenente ogni punto.
1
0
2
1
Stai organizzando una lotteria online.Per partecipare, una persona scommette
un singolo numero intero.Quindi disegni diversi segmenti di numeri interi consecutivi
casuale.Il payo ﬀ di un partecipante è proporzionale al numero di segmenti
che contengono il numero del partecipante.Hai bisogno di un algoritmo e ﬃ cience per
Calcolo dei pagamenti per tutti i partecipanti.Una semplice scansione dell'elenco di tutti
Gli intervalli per ogni partecipante sono troppo lenti poiché la tua lotteria è molto popolare:
Hai migliaia di partecipanti e migliaia di gamme.
Formato di input.La prima linea contiene due numeri interi non negativi S e P
definendo il numero di segmenti e il numero di punti su una linea,
rispettivamente.Le linee S successive contengono due numeri interi AI, che definiscono il
I-Th Segmento [AI, BI].La riga successiva contiene punti di definizione degli interi P
x1, ..., xp.
Formato di output.p numeri interi non negativi k1, ..., kp dove ki è il numero
di segmenti che contengono XI.
Vincoli.1 ≤s, p ≤50000;−108 ≤i ≤bi ≤108 per tutti 1 ≤i ≤s;−108 ≤
XJ ≤108 per tutti 1 ≤j ≤p.

---
layout: 
title: Pagina 110
level: 3
---


6.5.Organizzare una lotteria
91
Campione 1.
Ingresso:
2 3
0 5
7 10
1 6 11
Produzione:
1 0 0
Abbiamo due segmenti e tre punti.Il primo punto sta solo in
Il primo segmento mentre i restanti due punti sono al di fuori di tutti
segmenti.
Campione 2.
Ingresso:
1 3
-10 10
-100 100 0
Produzione:
0 0 1
Campione 3.
Ingresso:
3 2
0 5
-3 2
7 10
1 6
Produzione:
2 0

---
layout: 
title: Pagina 111
level: 3
---


92
Capitolo 6. Divide-and-Conquer
6.6
Punti più vicini
Problema di punti più vicini
Trova la coppia più vicina di punti in una serie di punti
su un aereo.
Input: un set di punti su un piano.
Produzione:
La distanza minima
tra una coppia di questi punti.
Questo problema di geometria computazionale ha molte applicazioni in
Pulter Graphics and Vision.
Un algoritmo ingenuo con corsa quadratica
Il tempo itera attraverso tutte le coppie di punti per trovare la coppia più vicina.Il tuo obiettivo
è progettare un algoritmo O (NLOGN) di divisione e conquista.
Per risolvere questo problema nel tempo O (NLOGN), dividiamo prima il dato
n punti da una linea verticale opportunamente scelta in due metà S1 e S2
di dimensioni n
2 (Supponiamo per semplicità che tutti i coordinati X dei punti di input
sono diversi).Effettuando due chiamate ricorsive per i set S1 e S2, abbiamo trovato
Le distanze minime D1 e D2 in questi sottoinsiemi.Sia d = min {d1, d2}.
d2
D1
Resta da verificare se esistono punti p1 ∈S1 e p2 ∈S2 in modo tale
La distanza tra loro è più piccola di D.Non possiamo avere ordini di controllare
tutte possibili tali coppie poiché ci sono n
2 · n
2 = θ (N2) di essi.Per verificarlo
più veloce, scartiamo per la prima volta tutti i punti da S1 e S2 la cui distanza X al
La linea media è maggiore di D.Cioè, ci concentriamo sulla seguente striscia:

---
layout: 
title: Pagina 112
level: 3
---


6.6.Punti più vicini
93
d2
D1
D
D
Fermati e pensa.Perché possiamo restringere la ricerca a questa striscia?
Ora, ordiniamo i punti della striscia dai loro coordinati Y e denotiamo il
Elenco ordinato risultante da P = [P1, ..., PK].Si scopre che se | i - j |> 7, quindi il
La distanza tra i punti PI e PJ è sicuramente maggiore di D.Questo segue
Dalla pausa di esercizio sotto.
Pausa di esercizio.Partizione della striscia in quadrati D × D come mostrato di seguito e
Mostra che ciascuno di questi quadrati contiene al massimo quattro punti di input.
d2
D1
D
D
Ciò si traduce nel seguente algoritmo.Per prima cosa ordiniamo i punti n indicati
dai loro coordinati X e quindi dividere l'elenco ordinato risultante in due
metà S1 e S2 della dimensione n
2. facendo una chiamata ricorsiva per ciascuno dei
Imposta S1 e S2, abbiamo trovato le distanze minime D1 e D2 in esse.Permettere
d = min {d1, d2}.Tuttavia, non abbiamo ancora finito perché abbiamo anche bisogno di trovare il
distanza minima tra i punti da diversi set (cioè un punto da S1
e un punto da S2) e verificare se è più piccolo di d.Per esibirsi

---
layout: 
title: Pagina 113
level: 3
---


94
Capitolo 6. Divide-and-Conquer
Tale controllo, infiliamo il set di punti iniziali e manteniamo solo quei punti
la cui distanza X alla linea media non supera d.Successivamente, noi
Ordina il set di punti nella striscia risultante dai loro coordinati Y e scansionali
l'elenco risultante di punti.Per ogni punto, calcoliamo la sua distanza
I sette punti successivi in ​​questo elenco e calcola d ′, il minimo
Distanza che abbiamo incontrato durante questa scansione.Successivamente, torniamo
min {d, d ′}.
Il tempo di esecuzione dell'algoritmo soddisfa la relazione di ricorrenza
T (n) = 2 · t
n
2

+ O (NLOGN).
Il termine O (NLOGN) deriva dall'ordinamento dei punti nella striscia
Y-coordina ad ogni iterazione.
Pausa di esercizio.Dimostra che t (n) = O (nlog2 n) analizzando la ricorsione
albero dell'algoritmo.
Pausa di esercizio.Mostra come portare il tempo di esecuzione a O (NLOGN)
evitando l'ordinamento ad ogni chiamata ricorsiva.
Formato di input.La prima riga contiene il numero di punti n.Ognuno di
Seguendo N linee definisce un punto (xi, yi).
Formato di output.La distanza minima.Ricordiamo che la distanza tra
i punti (x1, y1) e (x2, y2) sono uguali a
P
(x1 −x2) 2 + (y1 −y2) 2.Così,
Mentre l'input contiene solo interi, l'output non è necessariamente
intero e devi prestare attenzione alla precisione quando si riferisce
Esso.Il valore assoluto della differenza tra la risposta del tuo
Programma e il valore ottimale dovrebbero essere al massimo 10-3.Per garantire
Questo, produce la tua risposta con almeno quattro cifre dopo il decimale
punto (altrimenti anche la risposta calcolata correttamente potrebbe non passare
il nostro selezionatore a causa degli errori di arrotondamento).
Vincoli.2 ≤n ≤105;−109 ≤xi, yi ≤109 sono numeri interi.

---
layout: 
title: Pagina 114
level: 3
---


6.6.Punti più vicini
95
Campione 1.
Ingresso:
2
0 0
3 4
Produzione:
5.0
Ci sono solo due punti alla distanza 5.
Campione 2.
Ingresso:
11
4 4
-2 -2
-3 -4
-1 3
2 3
-4 0
1 1
-1 -1
3 -1
-4 2
-2 4
Produzione:
1.414213
La distanza più piccola è
√
2. Ci sono due coppie di punti in questo
distanza mostrata in blu e rosso sotto: (−1, −1) e (−2, −2);(−2,4)
e (−1,3).
X
y

---
layout: 
title: Pagina 115
level: 3
---


96
Capitolo 6. Divide-and-Conquer

---
layout: 
title: Pagina 116
level: 3
---


Capitolo 7: Programmazione dinamica
In questo capitolo, implementerai varie algo di programmazione dinamica
ritmi e vedranno come risolvono i problemi che hanno eluso tutti i tentativi
Per risolverli usando strategie avide o di divisione e conquista.Ci sono
Innumerevoli applicazioni di programmazione dinamica in pratica che vanno
Alla ricerca di pagine Internet simili alla previsione genica nelle sequenze di DNA.
Imparerai come la stessa idea aiuta a fare automaticamente l'ortografia
correzioni e per trovare le differenze tra due versioni della stessa
testo.
¢ 1
¢ 3
¢ 4
Soldi
Cambiare di nuovo
1
+1
× 2
× 3
Primitivo
Calcolatrice
corto
Hort
porta
porti
Modifica la distanza
7
2
9
3
1
5
9
4
2
8
1
3
9
7
Più lungo comune
Successivamente di
Due sequenze
8
3
2
1
7
3
8
2
1
3
8 10 7
6
8
3
1
4
7
Più lungo comune
Successivamente di
Tre sequenze
Massimo
Quantità di oro
3
6
4
1
9
6
9
1
Partizionamento
Souvenir
((8 −5) × 3) = 9
(8 - (5 × 3)) = −7
Valore massimo
di un arith-
espressione metica
97

---
layout: 
title: Pagina 117
level: 3
---


98
Capitolo 7. Programmazione dinamica
7.1
Il denaro cambia di nuovo
¢ 1
¢ 3
¢ 4
Come già sappiamo, uno strato naturale avido
Egy per il problema del cambiamento non funziona
correttamente per qualsiasi insieme di denominazioni.Per
Esempio, se le denominazioni disponibili sono
1, 3 e 4, l'algoritmo avido cambierà
6 centesimi usando tre monete (4 + 1 + 1)
Può essere modificato usando solo due monete (3+3).
Il tuo obiettivo ora è applicare pro-
Gramming per risolvere il cambio di denaro
Problema per le denominazioni 1, 3 e 4.
Formato di input.Denaro intero.
Formato di output.Il numero minimo di monete con denominazioni
1, 3, 4 che cambia denaro.
Vincoli.1 ≤money ≤103.
Campione 1.
Ingresso:
2
Produzione:
2
2 = 1 + 1.
Campione 2.
Ingresso:
34
Produzione:
9
34 = 3 + 3 + 4 + 4 + 4 + 4 + 4 + 4 + 4.

---
layout: 
title: Pagina 118
level: 3
---


7.2.Calcolatore primitivo
99
7.2
Calcolatore primitivo
Problema di calcolatrice primitiva
Trova il numero minimo di operazioni necessarie
Per ottenere un numero intero positivo n da 1 usando solo tre
Operazioni: aggiungi 1, moltiplica per 2 e moltiplica
di 3.
Input: un numero intero n.
Output: il numero minimo di
Operazioni "+1", "× 2" e "× 3"
necessario per ottenere n da 1.
1
+1
× 2
× 3
Ti viene dato un calcolatore che esegue solo i seguenti tre opera
Azioni con un numero intero x: aggiungi 1 a x, moltiplicare x per 2 o moltiplicare x per 3.
Dato un numero intero positivo n, il tuo obiettivo è quello di trovare il numero minimo di op-
Erazioni necessarie per ottenere n a partire dal numero 1. Prima di risolvere il
Sfida di programmazione di seguito, testare l'intuizione con il nostro cal- cal-
Puzzle di Culator.
Proviamo una strategia avida per risolvere questo problema: se l'attuale numero
BER è al massimo n/3, moltiplicalo per 3;Se è più grande di n/3, ma al massimo n/2,
moltiplicarlo per 2;altrimenti aggiungi 1 ad esso.Ciò si traduce nel seguente pseu-
docode.
Greedcalculator (N):
NUMOPERAZIONI ← 0
CurrentNumber ← 1
Mentre CurrentNumber <n:
Se corrente Number ≤N/3:
CurrentNumber ← 3 × CurrentNumber
altrimenti se corrente Number ≤n/2:
CurrentNumber ← 2 × CurrentNumber
altro:
CurrentNumber ← 1 + CurrentNumber
NUMOPERAZIONI ← NUMOPERAZIONI + 1
restituire numoperazioni

---
layout: 
title: Pagina 119
level: 3
---


100
Capitolo 7. Programmazione dinamica
Fermati e pensa.Puoi trovare un numero n tale
Greedcalculator (N) produce un risultato errato?
Formato di input.Un numero intero n.
Formato di output.Nella prima riga, produrre il numero minimo k di opera
le zioni necessarie per ottenere n da 1. Nella seconda riga, produce una sequenza di
Numeri intermedi.Cioè, la seconda riga dovrebbe contenere posi-
interi tive a0, a1, ..., ak tale che a0 = 1, ak = n e per tutti 1 ≤i ≤k,
L'IA è uguale a Ai - 1 + 1, 2Ai - 1 o 3Ai - 1.Se ce ne sono molti di questi
sequenze, output chiunque di esse.
Vincoli.1 ≤n ≤106.
Campione 1.
Ingresso:
1
Produzione:
0
1
Campione 2.
Ingresso:
96234
Produzione:
14
1 3 9 10 11 22 66 198 594 1782 5346 16038 16039 32078 96234
Un altro output valido in questo caso è “1 3 9 10 11 33 99 297 891 2673
8019 16038 16039 48117 96234 ".

---
layout: 
title: Pagina 120
level: 3
---


7.3.Modifica la distanza
101
7.3
Modifica la distanza
Modificare il problema della distanza
Calcola la distanza di modifica tra due stringhe.
Input: due stringhe.
Produzione:
Il numero minimo
di inserimenti a singolo simbolo, dele-
zioni e sostituzioni a trans-
Formare una stringa nell'altra.
corto
Hort
porta
porti
Modifica la distanza ha molte applicazioni in biologia computazionale, naturale
Elaborazione del linguaggio, controllo ortografico, ecc. Ad esempio, i biologi spesso
Analizza le distanze di modifica quando cercano mutazioni che causano la malattia.
Formato di input.Due stringhe costituite da lettere latine minuscole, ciascuna
una linea separata.
Formato di output.La distanza di modifica tra loro.
Vincoli.La lunghezza di entrambe le stringhe è almeno 1 e al massimo 100.
Campione 1.
Ingresso:
corto
porti
Produzione:
3
La seconda stringa può essere ottenuta da quella prima per delet-
ing s, sostituendo H per p e inserendo s.Questo può essere compatto
Visualizzato dal seguente allineamento.
S
H
o
R
T
-
-
P
o
R
T
S

---
layout: 
title: Pagina 121
level: 3
---


102
Capitolo 7. Programmazione dinamica
Campione 2.
Ingresso:
la modifica
distanza
Produzione:
5
Elimina E, inserire s dopo I, sostituire I per a, sostituire g per c, inserire e
all'estremità.
e
D
io
-
T
io
N
G
-
-
D
io
S
T
UN
N
C
e
Campione 3.
Ingresso:
ab
ab
Produzione:
0

---
layout: 
title: Pagina 122
level: 3
---


7.4.La più lunga successione comune di due sequenze
103
7.4
La sottosequenza comune più lunga di due se-
QUESTIONE
La sottosequenza comune più lunga di due se-
Problema delle tracce
Calcola la sottosequenza comune più lunga di due
sequenze.
Input: due sequenze.
Produzione:
Il loro più comune comune
sotto sequenza.
7
2
9
3
1
5
9
4
2
8
1
3
9
7
Date due sequenze a = (a1, a2, ..., an) e b = (b1, b2, ..., bm), trovano il
Lunghezza della loro più lunga sottosequenza comune, cioè il più grande non negativo
intero p tale che esistono indici
1 ≤i1 <i2 <··· <ip ≤n,
1 ≤j1 <j2 <··· <jp ≤m.
tale che
ai1 = bj1,
ai2 = bj2,
.
.
.
AIP = BJP.
Il problema ha applicazioni nel confronto dei dati (ad es. UTILITÀ DIFF, FONTE
operazione in vari sistemi di controllo della versione), bioinformatica (finzione sim
ilarità tra geni in varie specie) e altre.
Formato di input.Prima riga: n.
Seconda riga: A1, A2, ..., an.
Terza riga: m.
Quarta riga: B1, B2, ..., BM.
Formato di output.P.

---
layout: 
title: Pagina 123
level: 3
---


104
Capitolo 7. Programmazione dinamica
Vincoli.1 ≤n, m ≤100;−109 ≤i, bi ≤109 per tutti i.
Campione 1.
Ingresso:
3
2 7 5
2
2 5
Produzione:
2
Una sottosequenza comune della lunghezza 2 è (2,5).
Campione 2.
Ingresso:
1
7
4
1 2 3 4
Produzione:
0
Le due sequenze non condividono elementi.
Campione 3.
Ingresso:
4
2 7 8 3
4
5 2 8 7
Produzione:
2
Una sottosequenza comune è (2,7).Un altro è (2,8).

---
layout: 
title: Pagina 124
level: 3
---


7.5.La più lunga successione comune di tre sequenze
105
7.5
Sottosequenza comune più lunga di tre se-
QUESTIONE
Sottosequenza comune più lunga di tre se-
Problema delle tracce
Calcola la sottosequenza comune più lunga di
Tre sequenze.
Input: tre sequenze.
Produzione:
Il loro più comune comune
sotto sequenza.
8
3
2
1
7
3
8
2
1
3
8 10 7
6
8
3
1
4
7
Date tre sequenze A = (A1, A2, ..., AN), B = (B1, B2, ..., BM) e C =
(C1, C2, ..., Cl), trovò la lunghezza della loro più lunga sottosequenza comune, cioè,
il più grande intero non negativo P tale che esistono indici
1 ≤i1 <i2 <··· <ip ≤n,
1 ≤j1 <j2 <··· <jp ≤m,
1 ≤k1 <k2 <··· <kp ≤l
tale che
ai1 = bj1 = ck1,
ai2 = bj2 = ck2,
.
.
.
AIP = BJP = CKP.
Formato di input.Prima riga: n.
Seconda riga: A1, A2, ..., an.
Terza riga: m.
Quarta riga: B1, B2, ..., BM.Quinta riga: l.Sesta riga: C1, C2, ..., Cl.
Formato di output.P.
Vincoli.1 ≤n, m, l ≤100;−109 ≤i, bi, ci ≤109.

---
layout: 
title: Pagina 125
level: 3
---


106
Capitolo 7. Programmazione dinamica
Campione 1.
Ingresso:
3
1 2 3
3
2 1 3
3
1 3 5
Produzione:
2
Una sottosequenza comune della lunghezza 2 è (1,3).
Campione 2.
Ingresso:
5
8 3 2 1 7
7
8 2 1 3 8 10 7
6
6 8 3 1 4 7
Produzione:
3
Una sottosequenza comune della lunghezza 3 in questo caso è (8,3,7).Un altro
Uno è (8,1,7).

---
layout: 
title: Pagina 126
level: 3
---


7.6.Quantità massima di oro
107
7.6
Quantità massima di oro
Quantità massima di problema d'oro
Data una serie di barre d'oro di vari pesi e
uno zaino, posizionare più oro possibile in
lo zaino.
Ingresso:
Un set di n barre d'oro di
pesi w1, ..., wn e uno zaino
Ciò può contenere al massimo i chili.
Output: trova un sottoinsieme di barre d'oro
di peso totale massimo non ex-
Ceeding W.
Hai trovato un set di barre d'oro e il tuo obiettivo è mettere in valigia lo stesso oro quanto
Possibile nella borsa che può contenere al massimo.Ce n'è solo uno
Copia di ogni barra e per ogni barra puoi prenderla o no (da cui tu
non può prendere una frazione di un bar).
Una strategia naturale avida è quella di afferrare la barra più pesante che ancora si adatta
la capacità rimanente dello zaino e iterazione.
Fermati e pensa.Trova un input per il quale l'algoritmo avido fallisce.
Formato di input.La prima linea dell'ingresso contiene la capacità W di a
zaino e il numero N di barre d'oro.La riga successiva contiene n
Integers W1, ..., WN che definisce i pesi delle barre d'oro.
Formato di output.Il peso massimo dell'oro che si adatta a uno zaino di
Capacità W.
Vincoli.1 ≤w ≤104;1 ≤n ≤300;0 ≤w1, ..., wn ≤105.

---
layout: 
title: Pagina 127
level: 3
---


108
Capitolo 7. Programmazione dinamica
Campione.
Ingresso:
10 3
1 4 8
Produzione:
9
La somma dei pesi del primo e dell'ultimo bar è pari a 9.

---
layout: 
title: Pagina 128
level: 3
---


7.7.Souvenir di partizionamento
109
7.7
Souvenir di partizionamento
Problema di 3 partizioni
Partizione Un insieme di numeri interi in tre sottoinsiemi con
somme uguali.
Input: numeri interi v1, v2, ..., vn.
Produzione:
Controllo
se
È
possibile di partizionarli in
Tre sottoinsiemi con somme uguali, cioè,
Controlla se esistono tre
Disjoint Imposta S1, S2, S3 ⊆ {1,2, ..., N}
tale che s1 ∪s2 ∪s3 = {1,2, ..., n}
E
X
i∈S1
vi =
X
j∈S2
vj =
X
k∈S3
vk.
3
6
4
1
9
6
9
1
Tu e due dei tuoi amici sono appena tornati a casa dopo la visita
vari paesi.Ora vorresti dividere uniformemente tutti i souvenir
Che tutti e tre avete comprato.
Formato di input.La prima linea contiene un numero intero n.La seconda riga con-
Tains Integers v1, v2, ..., vn separato da spazi.
Formato di output.Output 1, se è possibile partizione v1, v2, ..., vn in tre
sottoinsiemi con somme uguali e 0 altrimenti.
Vincoli.1 ≤n ≤20, 1 ≤vi ≤30 per tutti i.
Campione 1.
Ingresso:
4
3 3 3 3
Produzione:
0

---
layout: 
title: Pagina 129
level: 3
---


110
Capitolo 7. Programmazione dinamica
Campione 2.
Ingresso:
1
40
Produzione:
0
Campione 3.
Ingresso:
11
17 59 34 57 17 23 67 1 18 2 59
Produzione:
1
34 + 67 + 17 = 23 + 59 + 1 + 17 + 18 = 59 + 2 + 57.
Campione 4.
Ingresso:
13
1 2 3 4 5 5 5 7 7 8 10 12 19 25
Produzione:
1
1 + 3 + 7 + 25 = 2 + 4 + 5 + 7 + 8 + 10 = 5 + 12 + 19.

---
layout: 
title: Pagina 130
level: 3
---


7.8.Valore massimo di un'espressione aritmetica
111
7.8
Valore massimo di un espresso aritmetico
Sion
Valore massimo di un espresso aritmetico
problema di sion
Tra parentesi un'espressione aritmetica a maxi-
mize il suo valore.
Input: un'espressione aritmetica
composto da cifre e oltre,
Minus e segni di moltiplicazione.
Output: aggiungi parentesi al
espressione per massimizzare la sua
valore.
((8 −5) × 3) = 9
(8 - (5 × 3)) = −7
Ad esempio, per un'espressione (3 + 2 × 4) ci sono due modi di parente
tesizzandolo: (3 + (2 × 4)) = 11 e ((3 + 2) × 4) = 20.
Pausa di esercizio.Tra parentesi l'espressione "(5 −8 + 7 × 4 −8 + 9) a
massimizza il suo valore.
Formato di input.L'unica riga dell'ingresso contiene una stringa S di lunghezza 2n+
1 Per alcuni n, con simboli S0, S1, ..., S2N.Ogni simbolo in un pareggio
La posizione di S è una cifra (cioè un numero intero da 0 a 9) mentre ciascuno
Il simbolo in una posizione dispari è una delle tre operazioni da {+,-, \*}.
Formato di output.Il valore massimo possibile dell'Aritmetica
pressione tra tutti i possibili ordini di applicazione dell'opera aritmetica
zioni.
Vincoli.1 ≤n ≤14 (da qui la stringa contiene al massimo 29 simboli).
Campione.
Ingresso:
5-8+7 \*4-8+9
Produzione:
200
200 = (5 - ((8 + 7) × (4 - (8 + 9))))

---
layout: 
title: Pagina 131
level: 3
---


112
Capitolo 7. Programmazione dinamica

---
layout: 
title: Pagina 132
level: 3
---


Appendice
Flag del compilatore
C (GCC 5.2.1).Estensioni di file: .C.Flag:
gcc -pipe -o2 -std = c11 -lm
C ++ (G ++ 5.2.1).Estensioni di file: .cc, .cpp.Flag:
g ++ -pipe -o2 -std = c ++ 14 -lm
Se il tuo compilatore C/C ++ non riconosce -Std = C ++ 14 tocco, prova RE
Posizionarlo con -std = c ++ 0x bandiera o compilare senza questa vasca
(Tutte le soluzioni di avviamento possono essere compilate senza di essa).Su linux e ma-
Perché molto probabilmente hai il compilatore richiesto.Su Windows,
Puoi utilizzare il tuo compilatore o installare preferito, ad esempio Cygwin.
C# (Mono 3.2.8).Estensioni di file: .cs.Flag:
MCS
Haskell (GHC 7.8.4).Estensioni di file: .hs.Flag:
GHC -O2
Java (Open JDK 8).Estensioni di file: .java.Flag:
Javac -Codiing UTF -8
Java -xmx1024m
JavaScript (nodo v6.3.0).Estensioni di file: .js.Flag:
Nodejs
Python 2 (Cpython 2.7).Estensioni di file: .py2 o .py (un file che termina in .py
Deve avere una prima riga che è un commento contenente "Python2").
Nessuna opzione:
Python2
113

---
layout: 
title: Pagina 133
level: 3
---


114
Appendice
Python 3 (Cpython 3.4).Estensioni di file: .py3 o .py (un file che termina in .py
Deve avere una prima riga che è un commento contenente "Python3").
Nessuna opzione:
Python3
Ruby (Ruby 2.1.5).Estensioni di file: .rb.
rubino
Scala (Scala 2.11.6).Estensioni di file: .Scala.
Scalac
Domande frequenti
Quali sono i possibili risultati di classificazione?
Ci sono solo due risultati: "Pass" o "No Pass".Per passare, il tuo programma
deve restituire una risposta corretta su tutti i casi di test che abbiamo preparato per te e
fallo sotto il tempo e i vincoli di memoria specificati nel problema
dichiarazione.Se la tua soluzione passa, ottieni il feedback corrispondente
"Buon lavoro!"E ottieni un punto per il problema.La tua soluzione fallisce se neanche
Crash, restituisce una risposta errata, funziona troppo a lungo o usa troppo
Memoria per qualche caso di test.Il feedback conterrà l'indice del primo
Caso di prova su cui la soluzione non è riuscita e il numero totale di casi di test
nel sistema.I test per il problema sono numerati da 1 al totale
Numero di casi di test per il problema e il programma viene sempre testato
su tutti i test nell'ordine dal primo test al test con il più grande
numero.
Ecco i possibili risultati:
• Buon lavoro!Evviva!La tua soluzione è passata e ottieni un punto!
• Risposta sbagliata.La tua soluzione emette una risposta errata per alcuni test
caso.Controlla di considerare correttamente tutti i casi, evita l'intero
eccesso di flusso, produrre gli spazi bianchi richiesti, produrre il punto di fluochi
numeri con precisione richiesta, non produrre nulla in addii
a ciò che ti viene chiesto di emettere nella specifica di output di
la dichiarazione del problema.

---
layout: 
title: Pagina 134
level: 3
---


Appendice
115
• Limite di tempo superato.La tua soluzione ha funzionato più a lungo dell'al-
Limite di tempo ridotto per un caso di test.Controlla di nuovo il tempo di esecuzione di
la tua implementazione.Prova il tuo programma a livello locale sulla prova di Max-
dimensione imum specificata nell'istruzione problema e controlla quanto tempo
lavori.Controlla che il tuo programma non attenda qualche input da
l'utente che lo fa aspettare per sempre.
• Limite di memoria superato.
La tua soluzione ha utilizzato più dell'al-
Limite di memoria ridotta per un caso di prova.
Stimare l'importo di
memoria che il tuo programma userà nel peggiore dei casi e
Verificare che non superi il limite di memoria.Controlla che il tuo
Le strutture di dati si adattano al limite di memoria.Controlla di non essere crei
mangiato grandi array o elenchi o vettori costituiti da array vuoti o vuoti
Stringhe, dal momento che in alcuni casi mangiano ancora memoria.Metti alla prova il tuo pro-
Gram localmente sui test di dimensioni massime specificate nel problema
Dichiarazione e osserva il consumo di memoria nel sistema.
• Impossibile controllare la risposta.
Forse il formato di output è
sbagliato.
Questo accade quando si produce qualcosa di diverso
del previsto.
Ad esempio, quando è necessario l'output
o "sì" o "no", ma invece output 1 o 0. o il tuo programma
ha un output vuoto.O il tuo programma emette non solo il corretto
risposta, ma anche alcune informazioni aggiuntive (segui il
Formato esatto di output specificato nell'istruzione problematica).
Forse
Il tuo programma non produce nulla, perché si blocca.
• Segnale sconosciuto 6 (o 7 o 8 o 11 o altri).Questo
accade quando il programma si arresta in modo anomalo.Può essere a causa di una divisione
a zero, accedere alla memoria al di fuori dei limiti dell'array, usando unini-
variabili tializzate, ricorsione eccessivamente profonda che innesca una pila
flusso, smistamento con un comparatore contraddittorio, rimuovendo gli elementi
Da una struttura di dati vuota, cercando di allocare troppa memoria,
e molte altre ragioni.Guarda il tuo codice e pensa a tutti quelli
possibilità.Assicurati di utilizzare lo stesso compilatore e lo stesso
Piani del compilatore come facciamo noi.
• Errore interno:
eccezione...
Molto probabilmente, hai inviato
un programma compilato anziché un codice sorgente.

---
layout: 
title: Pagina 135
level: 3
---


116
Appendice
• La classificazione non è riuscita.Qualcosa di sbagliato è successo con il sistema.Rif-
Porta questo tramite Coursera o EDX Help Center.
Perché i casi di test sono nascosti?
Vedere la Sezione 3.2.1.
Posso pubblicare la mia soluzione al forum?
Si prega di non pubblicare soluzioni nel forum o ovunque sul web,
Se una soluzione non supera i test (come in questo caso stai ancora rivelando
parti di una soluzione corretta).I nostri studenti seguono il codice d'onore: “Lo farò
non fare soluzioni ai compiti, quiz, esami, progetti e altri
firma disponibili per chiunque altro (tranne che nella misura in cui un incarico
consente esplicitamente la condivisione di soluzioni). "
Imparo cercando di correggere la mia soluzione?
La mia implementazione fallisce sempre nel grado, anche se ho già testato e
Lo stress lo ha testato molto.Non sarebbe meglio se mi avessi dato una soluzione a questo
Problema o almeno i casi di test che usi?Sarò quindi in grado di risolvere il mio codice
e imparerà come evitare di fare errori.Altrimenti, non sento che io
Impara qualsiasi cosa dalla risoluzione di questo problema.Sono solo bloccato.
Prima di tutto, imparare dai tuoi errori è uno dei modi migliori per imparare.
Il processo di tentativo di inventare nuovi casi di test che potrebbero fallire
Il grammo è difficile ma è spesso illuminante.Pensando alle proprietà di
Il tuo programma ti fa capire cosa succede all'interno del tuo programma
E nell'algoritmo generale stai studiando molto di più.
Inoltre, è importante essere in grado di trovare un bug nell'implementazione
senza conoscere un caso di test e senza avere una soluzione di riferimento, solo
come nella vita reale.Supponiamo di aver progettato un'applicazione e un infastidito
L'utente riferisce che si è arrestato in modo anomalo.Molto probabilmente, l'utente non ti dirà il
Sequenza esatta di operazioni che hanno portato a un incidente.Inoltre, ci sarà
nessuna applicazione di riferimento.Quindi, è importante imparare a trovare un bug
Nella tua implementazione tu stesso, senza un oracolo magico che ti dà neanche
Un caso di test che il programma non riesce o una soluzione di riferimento.Noi incoraggiamo
si utilizzano incarichi di programmazione in questa classe come un modo per esercitarsi
Questa importante abilità.

---
layout: 
title: Pagina 136
level: 3
---


Appendice
117
Se hai già testato il tuo programma su tutti i casi d'angolo, puoi
Immagina, costruito un insieme di casi di test manuali, test di stress applicato, ecc.
Ma il tuo programma fallisce ancora, prova a chiedere aiuto sul forum.Incoraggiamo
età per farlo prima spiegando che tipo di casi d'angolo hai
già considerato (può accadere che scrivendo un tale post lo farai
Renditi conto che hai perso alcuni casi d'angolo!), E solo dopo lo chiedi
Altri studenti per darti più idee per i casi di test.
