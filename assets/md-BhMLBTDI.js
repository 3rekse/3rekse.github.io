import{o as n,c as s,k as o,e,q as u,s as d,B as t}from"./modules/vue-C12uiUEh.js";import{I as m}from"./slidev/two-cols-header-BGdjP0CG.js";import{u as p,f as c}from"./slidev/context-DH053dPw.js";import"./index-BRfrW-eW.js";import"./modules/shiki-BBIst5IO.js";const g="/logica/3_6.png",_={__name:"sequenziale.md__slidev_461",setup(f){const{$slidev:v,$nav:z,$clicksContext:r,$clicks:A,$page:R,$renderContext:M,$frontmatter:l}=p();return r.setup(),(P,i)=>(n(),s(m,u(d(t(c)(t(l),460))),{right:o(a=>i[0]||(i[0]=[e("p",null,[e("img",{src:g,alt:"dflipflop"})],-1)])),left:o(a=>i[1]||(i[1]=[e("p",null,"Leggi: Per leggere il contenuto del registro numero m, inseriamo m nell’input dell’indirizzo.",-1),e("p",null,"Scrivi: Per scrivere un nuovo valore di dati d nel registro numero m, inseriamo m nel input dell’indirizzo, d nell’input in, e affermiamo il bit di input di load. Questo fa sì che la logica di accesso diretto della RAM selezioni il registro numero m, e il bit di carico lo abiliti. Nel prossimo ciclo di clock, il registro selezionato si impegnerà con il nuovo valore (d), e l’ output della RAM inizierà a emetterlo.",-1)])),default:o(()=>[i[2]||(i[2]=e("h2",null,"Ora tocca a te",-1)),i[3]||(i[3]=e("p",null,"Costruire una gerarchia di tali dispositivi di memoria, tutti larghi 16 bit, ma di dimensioni variabili: unità RAM8, RAM64, RAM512, RAM4K e RAM16K. Tutti questi chip di memoria hanno esattamente la stessa API, e quindi li descriviamo in un unico diagramma parametrico",-1)),i[4]||(i[4]=e("p",null,"La logica di accesso diretto della RAM selezionerà il registro numero m, che poi emetterà il suo valore di output al pin di output della RAM. Questa è un’operazione combinatoria, indipen- dente dal clock.",-1))]),_:1},16))}};export{_ as default};
