import{o as t,c as s,k as n,e,q as u,s as p,B as i}from"./modules/vue-C12uiUEh.js";import{_ as c}from"./slidev/intro-kNCWrU8C.js";import{u as l,f as m}from"./slidev/context-BB4SzEf7.js";import"./index-Dcu3EgtZ.js";import"./modules/shiki-BBIst5IO.js";const C={__name:"virtualMachine.md__slidev_618",setup(d){const{$slidev:f,$nav:_,$clicksContext:r,$clicks:z,$page:h,$renderContext:v,$frontmatter:o}=l();return r.setup(),(b,a)=>(t(),s(c,u(p(i(m)(i(o),617))),{default:n(()=>a[0]||(a[0]=[e("p",null,"Un semplice esempio di come un VMM deve interporsi su alcune operazioni sorge quando un processo in esecuzione su un dato sistema operativo cerca di fare una chiamata di sistema.",-1),e("p",null,"Ad esempio, il processo potrebbe cercare di chiamare open() su un file, o potrebbe chiamare read() per ottenere dati da esso, o potrebbe chiamare fork() per creare un nuovo processo.",-1),e("p",null,"In un sistema senza virtualizzazione, una chiamata di sistema viene eseguita con un’istruzione speciale; su MIPS, è un’istruzione di trap, e su x86, è l’istruzione int (un interrupt) con l’argomento 0x80.",-1),e("p",null,"Ecco la chiamata di libreria open su FreeBSD [B00] (ricorda che il tuo codice C prima fa una chiamata di libreria nella libreria C, che poi esegue la sequenza di assembly appropriata per effettivamente emettere l’istruzione di trap e fare una chiamata di sistema)",-1)])),_:1},16))}};export{C as default};
