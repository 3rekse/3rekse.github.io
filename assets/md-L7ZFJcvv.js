import{o as r,c as n,k as s,e,q as l,s as c,B as a}from"./modules/vue-BZNZ8Dvd.js";import{_ as u}from"./slidev/cover.vue_vue_type_script_setup_true_lang-DLxQiza0.js";import{u as m,f as p}from"./slidev/context-Ct6ukhQG.js";import"./index-CEdfyKoQ.js";import"./modules/shiki-Vdy54MD1.js";const S={__name:"ilcomputer.md__slidev_258",setup(d){const{$slidev:f,$nav:v,$clicksContext:t,$clicks:_,$page:h,$renderContext:x,$frontmatter:i}=m();return t.setup(),($,o)=>(r(),n(u,l(c(a(p)(a(i),257))),{default:s(()=>o[0]||(o[0]=[e("h3",null,"🧑‍🎓 Studente-6",-1),e("h2",null,"Capisco. Ma come si fa a prevenire che due core lavorino sullo stesso compito e causino un conflitto?",-1),e("h3",null,"🧠 Omarillo-2",-1),e("h2",null,'Ottima domanda! Qui entra in gioco il meccanismo delle "mutex" (mutual exclusion) e delle "barriere". Immagina di avere delle chiavi per accessi esclusivi a determinate risorse. Solo un core alla volta può usare una chiave, garantendo che non ci siano conflitti. E le barriere? Pensale come punti di incontro dove tutti devono aspettare prima di procedere insieme. 🔐🚧',-1)])),_:1},16))}};export{S as default};
