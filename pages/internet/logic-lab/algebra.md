---
layout: cover
title: Aritmetica e Algebra Booleana
level: 2
---
## SISTEMI DI NUMERAZIONE 

🐐 [Questa è una capra ?](https://www.artesvelata.it/tradimento-immagini-condizione-umana/)

🐐🐐🐐🐐🐐....🐐🐐🐐🐐 🇮🇹 ventisette- 🇬🇧Twenty seven

SdN
 
Unario : ||||..||  - Decimale 👦: 27   
Binario 🤖 : 11011 - Ottale : 22 - Esadecimale 1C 

L'**aritmetica** è la branca della matematica che si occupa delle proprietà e delle relazioni dei numeri in generale, e in particolare delle proprietà delle operazioni di addizione, sottrazione, moltiplicazione e divisione. È considerata la forma più elementare di matematica, e la maggior parte delle persone la impara a livello elementare.


Binary numerals are easy to:
| Compare | Add | Subtract | Multiply | Divide |
|---|---|---|---|---|
| Verify | Correct | Store | Transmit | Compress |

--- 
level: 3
title: Sdn egizio  

---

## Geroglifici 

Il sistema di numerazione egizio era un sistema di numerazione decimale utilizzato dagli antichi egizi. Utilizzava i seguenti simboli:

- Il simbolo del tratto (𓏺) rappresentava l'unità (1).
- Il simbolo dell'archetto (𓎼) rappresentava il dieci (10).
- Il simbolo del nodo (𓍢) rappresentava il cento (100).
- Il simbolo del giglio (𓆸) rappresentava il mille (1000).
- Il simbolo del dito (𓎛) rappresentava diecimila (10,000).
- Il simbolo del girino (𓆗) rappresentava centomila (100,000).
- Il simbolo dell'uomo con le braccia alzate (𓀀) rappresentava il milione (1,000,000).

Questi simboli venivano combinati per rappresentare numeri più grandi. Ad esempio, il numero 2763 sarebbe stato rappresentato come


#  𓆸𓆸 𓍢𓍢𓍢𓍢𓍢𓍢𓍢 𓎼𓎼𓎼𓎼𓎼𓎼  𓏺𓏺𓏺
La scoperta della Pietra di Rosetta nel 1799 ha fornito la chiave per decifrare questo antico sistema di scrittura. 


--- 
level: 3
title: Aritmetica booleana 

---

 # Aritmetica Booleana

L'**aritmetica booleana** è un sottocampo della aritmetica che si occupa di solo due possibili valori, vero o falso, spesso rispettivamente rappresentati come 1 e 0. 

Questo campo è alla base della logica dei computer e dei circuiti digitali.

Ci sono tre operazioni fondamentali:

1. **AND**: Operazione restituisce vero se entrambe le variabili sono vere. Altrimenti, restituisce falso.

2. **OR**: Operazione restituisce vero se almeno una delle variabili è vera. Altrimenti, restituisce falso.

3. **NOT**: Operazione inverte il valore della variabile. Se la variabile è vera, restituisce falso. Se la variabile è falsa, restituisce vero.


--- 
layout: cover
level: 3
title: Algebra  

---
# ALGEBRA

L'**algebra**, è un'estensione dell'aritmetica. L'aritmetica si occupa di numeri e operazioni, mentre l'algebra introduce concetti di variabili e funzioni.

In algebra, le lettere e i simboli vengono utilizzati per rappresentare numeri e quantità in formule e equazioni. L'algebra permette di risolvere problemi in cui alcuni dettagli numerici sono sconosciuti o variabili. 

Ad esempio, se sappiamo che `a + b = 10` e `a = 3`, possiamo usare l'algebra per scoprire che `b = 7`.


## Algebra booleana 

L'**Algebra Booleana** si occupa di variabili che assumono solo due valori, vero (o 1) e falso (o 0). 

Questo campo è fondamentale per la progettazione e la comprensione dei circuiti logici e dei computer.

Nell'Algebra Booleana, le tre operazioni fondamentali:
 **AND (E)**  **OR (O)**  **NOT (NON)** 

Possono essere combinate per creare espressioni booleane complesse. 
Ad esempio, l'espressione `(A AND B) OR NOT C` restituisce vero se `A` e `B` sono entrambi veri, o se `C` è falso.

--- 
layout: cover
level: 3
title: Le porte logiche

---

# Le porte logiche

**Le porte logiche** implementano fisicamente le operazioni booleane. 
Ad esempio, una porta AND ha due ingressi e un'uscita. L'uscita è vera solo se entrambi gli ingressi sono veri.

Imparare l'Algebra Booleana è fondamentale per capire come funzionano i computer e altri dispositivi digitali.

Impareremo come le funzioni booleane possono essere implementate fisicamente utilizzando le porte logiche. 

Vedremo poi come specificare le porte e i chip utilizzando 
un linguaggio di descrizione dell'hardware (HDL) e come simulare il comportamento delle specifiche dei chip risultanti utilizzando un simulatore hardware.

--- 
layout: cover
level: 3
title: chip 

---

# CHIP

Un "chip", noto anche come microchip o circuito integrato.

E'un piccolo pezzo di materiale semiconduttore, solitamente silicio, su cui sono incisi o "integrati" migliaia o milioni di piccoli componenti elettronici come transistor, diodi, resistenze e condensatori. Questi componenti sono collegati in modo da formare circuiti elettronici complessi.

I chip sono alla base di quasi tutti i dispositivi elettronici moderni, dai computer ai telefoni cellulari, dagli orologi digitali ai frigoriferi. Sono progettati per svolgere una vasta gamma di funzioni, tra cui elaborazione dei dati, memorizzazione, controllo di dispositivi e comunicazione.

Noi staimo imparando il liguaggio dei progettisti di circuiti che utilizzano linguaggi specializzati per descrivere la struttura e il comportamento dei circuiti integrati, compresi i chip. Queste descrizioni possono poi essere utilizzate per produrre fisicamente i chip in un processo di fabbricazione.


--- 
level: 3
title: chip 

---

# Fonderie di semiconduttori

 Aziende con processi di fabbricazione altamente specializzati per produrre i chip su larga scala. Alcune delle più grandi fonderie di semiconduttori includono:

- Taiwan Semiconductor Manufacturing Company (TSMC)
- Samsung Electronics
- Intel Corporation
- GlobalFoundries
- United Microelectronics Corporation (UMC)

--- 
level: 3
title: chip 

---

# Fabless semiconductor companies

Le aziende "fabless" di semiconduttori sono quelle che progettano e vendono circuiti integrati (chip) ma non possiedono impianti di produzione, o fonderie, per produrli fisicamente, si concentrano sulla progettazione e lo sviluppo di prodotti semiconduttori.

Alcuni esempi di aziende fabless di semiconduttori includono:

- Qualcomm
- NVIDIA
- Advanced Micro Devices (AMD)
- Broadcom
- MediaTek

Le aziende fabless si concentrano sulla progettazione di chip e sulla ricerca e sviluppo, senza dover gestire le costose operazioni di produzione e manutenzione degli impianti di produzione.

---
layout: two-cols-header
title: Gate Logici Elementari
level: 3

---

# Progetto 1

Gate (Porte) Logici Elementari 

::right::

![Bergson](https://cdn.studenti.stbm.it/images/2017/05/11/henri-bergson_200x300.jpeg)

[Henry Bergson (1859-1941)](https://www.studenti.it/henri-bergson-biografia-pensiero-filosofico-libri.html)

"L'intelligenza è la facoltà di creare oggetti artificiali, in particolare strumenti per creare strumenti."

::left::

Una tipica architettura informatica si basa su un insieme di gate logici elementari come And, Or, Mux, ecc., così come sulle loro versioni bitwise And16, Or16, Mux16, ecc. (supponendo una macchina a 16 bit). In questo progetto costruirai un tipico set di gate logici di base. 
Questi gate costituiscono i blocchi fondamentali da cui costruirai la CPU e le RAM del computer nei progetti successivi.

---
level: 3
title: Gate Logici Elementari
class: "border-l-36 border-green-600"
---

# Ora tocca a te 

## Obiettivo
Costruire i seguenti chip (usiamo i termini chip e gate in modo interscambiabile):

Not | And | Or
-|-|-
Xor | Mux | DMux
Not16 | And16 | Or16
Mux16 | Or8Way | Mux4Way16
Mux8Way16 | DMux4Way | DMux8Way

Poiché Nand è considerato primitivo, non è necessario implementarlo Nand (fornito).

---
layout: two-cols-header
level: 3
title: Gate primitivo NAND
---

## Teorema 
* Theorem: Any Boolean function can be realized using only Nand.

::right::

NAND table 
A | B |NAND | and | Not A | or |
-|-|-|-|-|-
0 | 0 | 1 | 0 |🧠|🧠|
0 | 1 | 1 | 0 |
1 | 0 | 1 | 0 | 
1 | 1 | 0 | 1 |

Gottfried Wilhelm Leibniz (1646–1716) : THE INVENTION OF COMPUTER ARITHMETIC

::left::

![Leibniz](/internet/images/logic-lab/logic-gates/leibniz.jpg)
---
level: 3
title: Funzioni con 2 bit 
---
## 2 Variabili binarie bit  2<sup>2</sup>   -> 2^(2<sup>2</sup>) = 16 Funzioni  

| Function (xy) | 00 | 01 | 10 | 11 | Function (xy) |00 | 01 | 10 | 11 |
|---|---|---|---|---|---|---|---|---|---|
| Constant 0 | 0 | 0 | 0 | 0 | x Nor y | 1 | 0 | 0 | 0 |
| x And y | 0 | 0 | 0 | 1 |  x = y | 1 | 0 | 0 | 1 |
| x And Not y | 0 | 0 | 1 | 0 | Not y | 1 | 0 | 1 | 0 |
| x | 0 | 0 | 1 | 1 | If y then x | 1 | 0 | 1 | 1 |
| Not x And y  | 0 | 1 | 0 | 0 | Not x | 1 | 1 | 0 | 0 |
| y | 0 | 1 | 0 | 1 | If x then y | 1 | 1 | 0 | 1 |
| x Xor y | 0 | 1 | 1 | 0 | x Nand y | 1 | 1 | 1 | 0 |
| x Or y | 0 | 1 | 1 | 1 | Constant 1 | 1 | 1 | 1 | 1 |


---
level: 3
title: Gate Logici Elementari
class: "border-l-36 border-green-600"
---

## File
Per ciascun chip Xxx nell'elenco, forniamo un programma Xxx.hdl scheletrico, anche chiamato file stub, con una sezione PARTS mancante. Inoltre, per ciascun chip forniamo uno script Xxx.tst che indica al simulatore hardware come testare il chip, insieme a un file di confronto Xxx.cmp contenente gli output corretti che ci si aspetta generi il test fornito. Il tuo compito è scrivere e testare le implementazioni dei chip (in particolare: completare i file Xxx.hdl forniti).

## Contratto
Per ciascun chip nell'elenco, la tua implementazione del chip (file Xxx.hdl modificato), testato dal file Xxx.tst fornito, deve generare gli output elencati nel file Xxx.cmp fornito. Se gli output effettivi generati dal tuo chip non corrispondono agli output desiderati, il simulatore segnalerà messaggi di errore.

---
level: 3
title: Gate Logici Elementari
class: "border-l-36 border-green-600"
---

# Costruzione dei chip

HDL è un formalismo per definire chip: oggetti le cui interfacce sono costituite da pin di input e output che trasportano segnali binari e le cui implementazioni sono disposizioni connesse di altri chip a livello inferiore.

Utilizzando l'[IDE online di Nand2Tetris](https://nand2tetris.github.io/web-ide/chip/) , tutti i file Xxx.hdl, Xxx.tst e Xxx.cmp sono disponibili nella memoria del tuo browser. 
Per sviluppare e testare un particolare chip, seleziona il progetto / chip dai menu a discesa del simulatore. 
Il tuo codice HDL modificato verrà salvato automaticamente. Per scaricare i file HDL sul tuo PC locale, fai clic sul pulsante di download. La versione attuale di tutti i file Xxx.hdl del progetto verrà scaricata come un unico file zip.

Documentazione HDL: A volte usiamo una notazione abbreviata. Ad esempio, il commento "if (in) out = 1, else out = 0" significa: "se (in = 1) allora impostare out a 0, altrimenti impostare out a 1". Allo stesso modo, la condizione "if (a and b) ..." significa "se (a = 1 e b = 1) ...", ecc.


---
layout: cover
level: 3
title: Esempio di HDL

---

# Esempio: 

Supponiamo di dover verificare se tre variabili a 1 bit a, b, c hanno lo stesso valore. 

Un modo per verificare questa uguaglianza a 3 vie è valutare la funzione booleana ¬((a ≠ b) ∨ (a ≠ c)). 

Notando che l'operatore binario diverso da può essere realizzato utilizzando un gate Xor, possiamo implementare questa funzione utilizzando il programma HDL mostrato.

```
CHIP TreUguali {

    IN a,b,c;
    OUT out;

    PARTS:
    Xor(a = a, b = b, out = ab);
    Xor(a = a, b = c, out = ac);
    Or (a=ab, b=ac, out=on);
    Nand(a=on,b=on , out=out );
    }
```

---
layout: cover
level: 3
title: Chp Set 

---

## Chip set  progetto 1

```
And(a= ,b= ,out= ) /* And gate */
And16(a= ,b= ,out= ) /* 16-bit And */
DMux(in= ,sel= ,a= ,b= ) /* Channels the input to one out of two outputs */
DMux4Way(in= ,sel= ,a= ,b= ,c= ,d= ) /* Channels the input to one out of four outputs */
DMux8Way(in= ,sel= ,a= ,b= ,c= ,d= ,e= ,f= ,g= ,h= ) /* Channels the input to one out of eight outputs */
Mux(a= ,b= ,sel= ,out= ) /* Selects between two inputs */
Mux16(a= ,b= ,sel= ,out= ) /* Selects between two 16-bit inputs */
Mux4Way16(a= ,b= ,c= ,d= ,sel= ,out= ) /* Selects between four 16-bit inputs */
Mux8Way16(a= ,b= ,c= ,d= ,e= ,f= ,g= ,h= ,sel= ,out= ) /* Selects between eight 16-bit inputs */
Nand(a= ,b= ,out= ) /* Nand gate (built-in) */
Not16(in= ,out= ) /* 16-bit Not */
Not(in= ,out= ) /* Not gate */
Or(a= ,b= ,out= ) /* Or gate */
Or8Way(in= ,out= ) /* 8-way Or */
Or16(a= ,b= ,out= ) /* 16-bit Or */
Xor(a= ,b= ,out= ) /* Xor gate */
```

---
level: 3
title: Gate Logici Elementari
class: "border-l-36 border-green-600"

---

# Porgetto 1 

Costruiamo il chipset che sarà poi utilizzato per costruire:

## l'Unità Logica Aritmetica (ALU)  


### Con il Progetto 2
 - Procediamo alla costruzione di una famiglia di addizionatori - chip progettati per sommare numeri.
 - Poi un grande passo avanti e costruiremo un'Unità Logica Aritmetica 
  
## Con il Progetto 3
- il sistema di memoria del computer.

--- 
level: 3
title: Somme 

---
# Algebra Binaria
## Somme binarie 4bit

| 0 | 0 | 0 | 1 | |(carry)| 1 | 0 | 0 | 1 | |
|---|---|---|---|---|---|---|---|---|---|---|
| | 1 | 0 | 0 | 1| x | | 1 | 0 | 0 | 1 |
| | 0 | 1 | 0 | 1| y | |1 | 1 | 0 | 1 |
|no | 1 | 1 | 1 | 0| x + y overflow| si | 0 | 1 | 1 | 0 |


---
level: 3
title: Complemento a 2 

---

# Positivi e Negativi in complemento a 2

|0| 0000|||a+b|
|---|---|---|---|---|
|1| 0001| 1111| -1||
|2| 0010| 1110| -2||
|3| 0011| 1101| -3||
|4| 0100| 1100| -4||
|5| 0101| 1011| -5||
|6| 0110| 1010| -6||
|7| 0111| 1001| -7||
|||1000| -8||


---
level: 3
title: Sommatore 
class: "border-l-36 border-green-600"
---

## Half-adder: [Sommatore](https://nand2tetris.github.io/web-ide/chip/)
designed to add two bits 
Inputs: a, b Outputs: sum, carry

| a | b |sum|carry|
|---|---|---|---|
| 0 | 0 | 0 | 0 |
| 0 | 1 | 1 | 0 |
| 1 | 0 | 1 | 0 |
| 1 | 1 | 0 | 1 |
* Full-adder: designed to add three bits Inputs: a, b, c sum, carry
* Adder: designed to add two n-bit numbers

---
level: 3
title: Sommatore 
class: "border-l-36 border-green-600"
---

 Full-adder: [Sommatore](https://nand2tetris.github.io/web-ide/chip/)
designed to add three bits Inputs: a, b, c  Outputs: sum, carry

| a | b | c |sum|carry|
|---|---|---|---|---|
| 0 | 0 | 0 | 0 |  0  |
| 0 | 0 | 1 | 1 |  0  |
| 0 | 1 | 0 | 1 |  0  |
| 0 | 1 | 1 | 0 |  1  |
| 1 | 0 | 0 | 1 |  0  |
| 1 | 0 | 1 | 0 |  1  |
| 1 | 1 | 0 | 0 |  1  |
| 1 | 1 | 1 | 1 |  1  |

---
level: 3
title: Sommatore 
class: "border-l-36 border-green-600"
---

#  [Adder](https://nand2tetris.github.io/web-ide/chip/) : designed to add two n-bit numbers

```
/**
 * 16-bit adder: Adds two 16-bit two's complement values.
 * The most significant carry bit is ignored.
 */
CHIP Add16 {
    IN a[16], b[16];
    OUT out[16];

    PARTS:
    //// Replace this comment with your code.
}
```
---
level: 3
title:  Incrementer
class: "border-l-36 border-green-600"

--- 
 
# 16-bit incrementer

```
/**
 * 16-bit incrementer:
 * out = in + 1
 */
CHIP Inc16 {
    IN in[16];
    OUT out[16];

    PARTS:
      PARTS:
    //// Replace this comment with your code.
}

```

---
level: 3
title: ALU
class: "border-l-36 border-green-600"
---

# Aritmetic Logic Unit ALU chip centrale del'Unità di elaborazione centrale del computer CPU. 

Progettata per eseguire un'intera serie di operazioni aritmetiche e logiche, è il cervello di calcolo del computer. 

- 2 Operandi di 16-bit in inputs x, y,
- 6 input bits: zx, nx, zy, ny, f, no. 
- 1 output a 16-bit out = secondo una delle seguenti funzioni:
 *                0, 1, -1,
 *                x, y, !x, !y, -x, -y,
 *                x + 1, y + 1, x - 1, y - 1,
 *                x + y, x - y, y - x,
 *                x & y, x | y

