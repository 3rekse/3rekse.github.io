import{o as i,c as r,k as s,e as l,q as n,s as u,B as a}from"./modules/vue-DBgDjl02.js";import{I as d}from"./slidev/default-BoXR918h.js";import{u as m,f as p}from"./slidev/context-CP5hkPrc.js";import"./index-CzwDcVxB.js";import"./modules/shiki-CR29Tdxk.js";const c={__name:"virtualMachine.md__slidev_625",setup(v){const{$slidev:f,$nav:g,$clicksContext:t,$clicks:b,$page:_,$renderContext:z,$frontmatter:o}=m();return t.setup(),($,e)=>(i(),r(d,n(u(a(p)(a(o),624))),{default:s(()=>e[0]||(e[0]=[l("p",null,"Nel lavoro su Disco, Rosenblum e colleghi hanno affrontato questo problema in modo abbastanza elegante sfruttando una modalità speciale fornita dall’hardware MIPS nota come modalità supervisore. Quando si esegue in questa modalità, non si ha ancora accesso alle istruzioni privilegiate, ma si può accedere a un po’ più di memoria rispetto alla modalità utente; il sistema operativo può usare questa memoria extra per le sue strutture dati e tutto funziona bene. Su hardware che non dispone di tale modalità, si deve eseguire il sistema operativo in modalità utente e utilizzare la protezione della memoria (tabelle delle pagine e TLB) per proteggere adeguatamente le strutture dati del sistema operativo. In altre parole, quando si passa al sistema operativo, il monitor dovrebbe rendere la memoria delle strutture dati del sistema operativo accessibile al sistema operativo tramite le protezioni delle tabelle delle pagine; quando si torna all’applicazione in esecuzione, la possibilità di leggere e scrivere il kernel dovrebbe essere rimossa.",-1)])),_:1},16))}},C=c;export{C as default};
