import{b as n,o as s,w as c,g as e,C as i,v as l,x as u,B as t}from"./modules/vue-BXqLZby3.js";import{_ as p}from"./slidev/cover.vue_vue_type_script_setup_true_lang-vcXHcYy4.js";import{u as m,f as d}from"./slidev/context-Co-6DO2t.js";import"./index-CDGWvc22.js";import"./modules/shiki-D1VZkxQz.js";const v={__name:"ilcomputer.md__slidev_110",setup(g){const{$clicksContext:o,$frontmatter:r}=m();return o.setup(),(f,a)=>(s(),n(p,l(u(t(d)(t(r),109))),{default:c(()=>a[0]||(a[0]=[e("p",null,[e("strong",null,"S12:"),i(" Ma se ASCII usa solo 7 bit, non può supportare alfabeti diversi da quello latino, come il greco antico. Che succede?")],-1),e("p",null,[e("strong",null,"O10 (Ricercatore in Machine Learning):"),i(' Per includere più caratteri, si potrebbe usare una codifica con più bit, magari 16, che offrirebbe circa 64.000 caratteri. Ma questo creerebbe un problema: come facciamo a sapere se un testo è codificato in ASCII o in questa nuova codifica "SuperASCII"?')],-1),e("p",null,[e("strong",null,"S11:"),i(" Non si può semplicemente aggiungere un bit in più per distinguere?")],-1),e("p",null,[e("strong",null,"O9:"),i(' L’idea è stata proprio questa! Un’idea geniale. Si usa un ottavo bit, un "'),e("strong",null,"bit di estensione"),i('". Se il bit è 0, si legge il carattere come un normale ASCII a 7 bit. Se invece è 1, significa che il carattere successivo non è ASCII e bisogna leggere i prossimi 15 bit per decodificarlo.')],-1)])),_:1,__:[0]},16))}};export{v as default};
